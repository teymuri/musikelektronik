{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Elektronische Musik / Musik-Elektronik Modul Kernfach Theorie III Das Ziel dieser \u00dcbung ist das Kennenlernen und Erproben der M\u00f6glichkeiten der elektronischen Musik in Theorie und Praxis anhand eines gemeinsam zu erarbeitenden Musikbeispiels. Die Analyse von Werken aus dem Repertoire ist ebenfalls ein Schwerpunkt dieses Seminars. Titel (dt.) der konkreten Lehrveranstaltung: Elektronische Musik + Musik-Elektronik Veranstaltungsart: Seminar/\u00dcbung (anmeldepflichtig) Semesterwochenstunden (SWS): 2 Leistungspunkte (ECTS): 2 Das Modul beginnt jeweils im Wintersemester und erstreckt sich \u00fcber zwei Semester. Bitte f\u00fchren Sie die Code-Beispiele in Ihrer SuperCollider-Umgebung aus und evaluieren Sie diese, um sich schneller mit dem Arbeitsverfahren in SuperCollider vertraut zu machen. Die Bearbeitung der \u00dcbungen in den Kapiteln wird ausdr\u00fccklich empfohlen. Bei Fragen wenden Sie sich bitte an das Lehrpersonal.","title":"Modulbeschreibung"},{"location":"#elektronische-musik-musik-elektronik","text":"","title":"Elektronische Musik / Musik-Elektronik"},{"location":"#modul-kernfach-theorie-iii","text":"Das Ziel dieser \u00dcbung ist das Kennenlernen und Erproben der M\u00f6glichkeiten der elektronischen Musik in Theorie und Praxis anhand eines gemeinsam zu erarbeitenden Musikbeispiels. Die Analyse von Werken aus dem Repertoire ist ebenfalls ein Schwerpunkt dieses Seminars. Titel (dt.) der konkreten Lehrveranstaltung: Elektronische Musik + Musik-Elektronik Veranstaltungsart: Seminar/\u00dcbung (anmeldepflichtig) Semesterwochenstunden (SWS): 2 Leistungspunkte (ECTS): 2 Das Modul beginnt jeweils im Wintersemester und erstreckt sich \u00fcber zwei Semester. Bitte f\u00fchren Sie die Code-Beispiele in Ihrer SuperCollider-Umgebung aus und evaluieren Sie diese, um sich schneller mit dem Arbeitsverfahren in SuperCollider vertraut zu machen. Die Bearbeitung der \u00dcbungen in den Kapiteln wird ausdr\u00fccklich empfohlen. Bei Fragen wenden Sie sich bitte an das Lehrpersonal.","title":"Modul Kernfach Theorie III"},{"location":"buffs/","text":"Buffers Buffers (auf Deutsch: Puffer) sind Speicherbereiche im Arbeitsspeicher unseres Rechners, auf die wir eine Sequenz von Zahlen schreiben k\u00f6nnen. Diese Zahlen repr\u00e4sentieren oft einzelne Samples einer Audio-Datei. Wir k\u00f6nnen mit der read -Methode (als Klassenmethode) auf dem Server einen Buffer reservieren und eine Audiodatei darauf schreiben: b = Buffer.read(s, \"/pfad/zur/audio-datei/glass-bowl.wav\") Mit der query -Methode k\u00f6nnen wir einige schnelle Informationen von unserem neu zugewiesenen Buffer abrufen, und mit der play -Methode k\u00f6nnen wir den Inhalt des Buffers abspielen: b.query /* bufnum: 8 numFrames: 118769 numChannels: 2 sampleRate: 44100.0 */ b.play Anmerkung Unter der Haube ruft die read -Methode die Klassenmethode alloc der Buffer-Klasse auf, die einen Puffer im Speicherplatz zuweist und die neu erstellte Pufferinstanz zur\u00fcckgibt. Das ist der Grund, warum wir diese Instanz der Variable b zuweisen, damit wir weiter mit unserem Pufferobjekt arbeiten k\u00f6nnen. Abspielen des Buffers Das Abspielen eines Buffers kann mithilfe des UGens PlayBuf erfolgen. Hier ist ein Beispiel, wie ein Puffer ( b ) mit PlayBuf abgespielt wird, zusammen mit der Erkl\u00e4rung der Argumente von PlayBuf : // Beispiel PlayBuf b = Buffer.read(s, \"/home/okavango/Desktop/glass-bowl.wav\"); ( // Das Argument `numChannels` bezieht sich auf die // Anzahl der Kan\u00e4le der Audio-Datei im Buffer. // Es ist sicherer, dieses Argument mit `b.numChannels` // zu belegen, damit automatisch die richtige Anzahl an // Kan\u00e4len \u00fcbermittelt wird. var numChannels = b.numChannels; /* Das Argument `rate` stellt die Abspielgeschwindigkeit des Buffers dar, wobei 1 der Originalgeschwindigkeit entspricht. Bei 2 wird der Buffer doppelt so schnell abgespielt (eine Oktave h\u00f6her), und bei 0.5 wird er halb so schnell abgespielt (eine Oktave tiefer). Negative Zahlen bewirken, dass der Buffer r\u00fcckw\u00e4rts abgespielt wird. */ var rate = 1; /* Das `doneAction`-Argument bewirkt, \u00e4hnlich wie bei den oben erkl\u00e4rten H\u00fcllkurven, dass das `PlayBuf`-UGen aus dem Arbeitsspeicher entfernt wird, sobald die Audiodatei bis zum Ende abgespielt ist. */ var action = 2; {PlayBuf.ar(numChannels: numChannels, bufnum: b, rate: rate, doneAction: action)}.play; ) Es kann passieren, dass die Audiodatei, die wir in den Puffer schreiben, mit einer anderen Abtastrate aufgenommen wurde, und der Supercollider-Server mit einer unterschiedlichen Abtastrate l\u00e4uft. Wenn dies der Fall ist, wird es zu Unstimmigkeiten bez\u00fcglich der Endabspiel-Frequenz kommen. Beispiel: Wenn wir eine Audiodatei mit einer Abtastrate von 44100 Hz auf einen Puffer laden und unser Server mit einer Taktfrequenz von 48000 Hz l\u00e4uft, wird das Audio um einen Faktor von 48000 / 44100 = 1.0884353741497 h\u00f6her klingen als die originale Audio-Datei. Um dies zu kompensieren (sprich einen Abspielfaktor von 1 zu erreichen), m\u00fcssen wir die Abspielrate mit dem Kehrwert dieses Faktors multiplizieren. Die Abtastraten der jeweiligen Server und des Buffers k\u00f6nnen wir folgenderma\u00dfen herausfinden: Mit den UGens BufSampleRate.ir(b) k\u00f6nnen wir die Abtastrate des Buffers b abrufen, und das UGen SampleRate.ir f\u00fcr die Abtastrate des Servers verwenden. Alternativ k\u00f6nnen wir die Variablen b.sampleRate (f\u00fcr den Buffer b ) und s.sampleRate (f\u00fcr den lokalen Server s ) verwenden. Also kann das obige Beispiel folgenderma\u00dfen verbessert werden, um etwaige Abtastdifferenzen beim Abspielen auszugleichen: ( var numChannels = b.numChannels; var rate = 1; var action = 2; { PlayBuf.ar( numChannels: numChannels, bufnum: b, rate: BufSampleRate.ir(b) / SampleRate.ir * rate, doneAction: action) }.play; ) Es ist ebenso m\u00f6glich, das UGen BufRateScale zu verwenden, das den erforderlichen Ausgleichsfaktor f\u00fcr uns berechnet. Dadurch ersparen wir uns den Schritt der Division: ( var numChannels = b.numChannels; var rate = 1; var action = 2; { PlayBuf.ar( numChannels: numChannels, bufnum: b, rate: BufRateScale.ir(b) * rate, doneAction: action) }.play; ) Drei weitere Argumente von PlayBuf sind trigger , loop und startPos . Ein Trigger findet statt, wenn ein Signal einen \u00dcbergang von einem negativen zu einem positiven (oder 0) Wert durchl\u00e4uft. Beispielsweise erfolgt der Trigger, wenn der Signalwert von -0.1234 auf 0.1234 oder \u00e4hnlich wechselt. Viele UGens erzeugen Werte, die sich im negativen und positiven Bereich bewegen. Ein Beispiel daf\u00fcr ist der Impulse UGen, der in einer bestimmten Frequenz den Wert 1 ausgibt und sonst 0. F\u00fchren Sie die folgende Zeile aus und beobachten Sie das Post-Fenster: {Impulse.kr(1).poll(trig: 2)}.play Wir \u00fcbergeben unserem PlayBuf ein Impulse -UGen als Argument f\u00fcr den Trigger: ( var numChannels = b.numChannels; var rate = 1; var action = 2; { PlayBuf.ar( numChannels: numChannels, trigger: Impulse.kr(1).poll(trig: 2), bufnum: b, rate: BufRateScale.ir(b) * rate, doneAction: action ) }.play; ) \u00dcbung \u00c4ndern Sie die Frequenz des Triggers, indem Sie die UGens MouseX als Argument f\u00fcr den Impulse -Generator verwenden, um Werte zwischen den Frequenzen 0.1 und 10 zu erhalten. Wenn das PlayBuf beendet wird, kommentieren Sie das doneAction -Argument aus und versuchen Sie es erneut. Versuchen Sie den Zusammenhang zu erkl\u00e4ren. Das Argument startPos bestimmt die Samplenummer, ab der das Abspielen beginnen soll. Mit dem UGen BufFrames erhalten wir die Anzahl der Samples im Buffer. M\u00f6gliche Werte f\u00fcr startPos k\u00f6nnen zwischen 0 und BufFrames liegen: ( var numChannels = b.numChannels; var rate = 1; var action = 2; { PlayBuf.ar( numChannels: numChannels, trigger: Impulse.kr(1), // Bewegen Sie die Maus nach oben und unten startPos: MouseY.kr(BufFrames.ir(b), 0), bufnum: b, rate: BufRateScale.ir(b) * rate ) }.play; ) Und das boolesche Argument loop (selten verwendet) setzt das Abspielen in einer Schleife fort: Sobald die Datei bis zum letzten Sample abgespielt wurde, beginnt das Abspielverfahren wieder beim ersten Sample und so weiter.","title":"Puffer"},{"location":"buffs/#buffers","text":"Buffers (auf Deutsch: Puffer) sind Speicherbereiche im Arbeitsspeicher unseres Rechners, auf die wir eine Sequenz von Zahlen schreiben k\u00f6nnen. Diese Zahlen repr\u00e4sentieren oft einzelne Samples einer Audio-Datei. Wir k\u00f6nnen mit der read -Methode (als Klassenmethode) auf dem Server einen Buffer reservieren und eine Audiodatei darauf schreiben: b = Buffer.read(s, \"/pfad/zur/audio-datei/glass-bowl.wav\") Mit der query -Methode k\u00f6nnen wir einige schnelle Informationen von unserem neu zugewiesenen Buffer abrufen, und mit der play -Methode k\u00f6nnen wir den Inhalt des Buffers abspielen: b.query /* bufnum: 8 numFrames: 118769 numChannels: 2 sampleRate: 44100.0 */ b.play Anmerkung Unter der Haube ruft die read -Methode die Klassenmethode alloc der Buffer-Klasse auf, die einen Puffer im Speicherplatz zuweist und die neu erstellte Pufferinstanz zur\u00fcckgibt. Das ist der Grund, warum wir diese Instanz der Variable b zuweisen, damit wir weiter mit unserem Pufferobjekt arbeiten k\u00f6nnen.","title":"Buffers"},{"location":"buffs/#abspielen-des-buffers","text":"Das Abspielen eines Buffers kann mithilfe des UGens PlayBuf erfolgen. Hier ist ein Beispiel, wie ein Puffer ( b ) mit PlayBuf abgespielt wird, zusammen mit der Erkl\u00e4rung der Argumente von PlayBuf : // Beispiel PlayBuf b = Buffer.read(s, \"/home/okavango/Desktop/glass-bowl.wav\"); ( // Das Argument `numChannels` bezieht sich auf die // Anzahl der Kan\u00e4le der Audio-Datei im Buffer. // Es ist sicherer, dieses Argument mit `b.numChannels` // zu belegen, damit automatisch die richtige Anzahl an // Kan\u00e4len \u00fcbermittelt wird. var numChannels = b.numChannels; /* Das Argument `rate` stellt die Abspielgeschwindigkeit des Buffers dar, wobei 1 der Originalgeschwindigkeit entspricht. Bei 2 wird der Buffer doppelt so schnell abgespielt (eine Oktave h\u00f6her), und bei 0.5 wird er halb so schnell abgespielt (eine Oktave tiefer). Negative Zahlen bewirken, dass der Buffer r\u00fcckw\u00e4rts abgespielt wird. */ var rate = 1; /* Das `doneAction`-Argument bewirkt, \u00e4hnlich wie bei den oben erkl\u00e4rten H\u00fcllkurven, dass das `PlayBuf`-UGen aus dem Arbeitsspeicher entfernt wird, sobald die Audiodatei bis zum Ende abgespielt ist. */ var action = 2; {PlayBuf.ar(numChannels: numChannels, bufnum: b, rate: rate, doneAction: action)}.play; ) Es kann passieren, dass die Audiodatei, die wir in den Puffer schreiben, mit einer anderen Abtastrate aufgenommen wurde, und der Supercollider-Server mit einer unterschiedlichen Abtastrate l\u00e4uft. Wenn dies der Fall ist, wird es zu Unstimmigkeiten bez\u00fcglich der Endabspiel-Frequenz kommen. Beispiel: Wenn wir eine Audiodatei mit einer Abtastrate von 44100 Hz auf einen Puffer laden und unser Server mit einer Taktfrequenz von 48000 Hz l\u00e4uft, wird das Audio um einen Faktor von 48000 / 44100 = 1.0884353741497 h\u00f6her klingen als die originale Audio-Datei. Um dies zu kompensieren (sprich einen Abspielfaktor von 1 zu erreichen), m\u00fcssen wir die Abspielrate mit dem Kehrwert dieses Faktors multiplizieren. Die Abtastraten der jeweiligen Server und des Buffers k\u00f6nnen wir folgenderma\u00dfen herausfinden: Mit den UGens BufSampleRate.ir(b) k\u00f6nnen wir die Abtastrate des Buffers b abrufen, und das UGen SampleRate.ir f\u00fcr die Abtastrate des Servers verwenden. Alternativ k\u00f6nnen wir die Variablen b.sampleRate (f\u00fcr den Buffer b ) und s.sampleRate (f\u00fcr den lokalen Server s ) verwenden. Also kann das obige Beispiel folgenderma\u00dfen verbessert werden, um etwaige Abtastdifferenzen beim Abspielen auszugleichen: ( var numChannels = b.numChannels; var rate = 1; var action = 2; { PlayBuf.ar( numChannels: numChannels, bufnum: b, rate: BufSampleRate.ir(b) / SampleRate.ir * rate, doneAction: action) }.play; ) Es ist ebenso m\u00f6glich, das UGen BufRateScale zu verwenden, das den erforderlichen Ausgleichsfaktor f\u00fcr uns berechnet. Dadurch ersparen wir uns den Schritt der Division: ( var numChannels = b.numChannels; var rate = 1; var action = 2; { PlayBuf.ar( numChannels: numChannels, bufnum: b, rate: BufRateScale.ir(b) * rate, doneAction: action) }.play; ) Drei weitere Argumente von PlayBuf sind trigger , loop und startPos . Ein Trigger findet statt, wenn ein Signal einen \u00dcbergang von einem negativen zu einem positiven (oder 0) Wert durchl\u00e4uft. Beispielsweise erfolgt der Trigger, wenn der Signalwert von -0.1234 auf 0.1234 oder \u00e4hnlich wechselt. Viele UGens erzeugen Werte, die sich im negativen und positiven Bereich bewegen. Ein Beispiel daf\u00fcr ist der Impulse UGen, der in einer bestimmten Frequenz den Wert 1 ausgibt und sonst 0. F\u00fchren Sie die folgende Zeile aus und beobachten Sie das Post-Fenster: {Impulse.kr(1).poll(trig: 2)}.play Wir \u00fcbergeben unserem PlayBuf ein Impulse -UGen als Argument f\u00fcr den Trigger: ( var numChannels = b.numChannels; var rate = 1; var action = 2; { PlayBuf.ar( numChannels: numChannels, trigger: Impulse.kr(1).poll(trig: 2), bufnum: b, rate: BufRateScale.ir(b) * rate, doneAction: action ) }.play; ) \u00dcbung \u00c4ndern Sie die Frequenz des Triggers, indem Sie die UGens MouseX als Argument f\u00fcr den Impulse -Generator verwenden, um Werte zwischen den Frequenzen 0.1 und 10 zu erhalten. Wenn das PlayBuf beendet wird, kommentieren Sie das doneAction -Argument aus und versuchen Sie es erneut. Versuchen Sie den Zusammenhang zu erkl\u00e4ren. Das Argument startPos bestimmt die Samplenummer, ab der das Abspielen beginnen soll. Mit dem UGen BufFrames erhalten wir die Anzahl der Samples im Buffer. M\u00f6gliche Werte f\u00fcr startPos k\u00f6nnen zwischen 0 und BufFrames liegen: ( var numChannels = b.numChannels; var rate = 1; var action = 2; { PlayBuf.ar( numChannels: numChannels, trigger: Impulse.kr(1), // Bewegen Sie die Maus nach oben und unten startPos: MouseY.kr(BufFrames.ir(b), 0), bufnum: b, rate: BufRateScale.ir(b) * rate ) }.play; ) Und das boolesche Argument loop (selten verwendet) setzt das Abspielen in einer Schleife fort: Sobald die Datei bis zum letzten Sample abgespielt wurde, beginnt das Abspielverfahren wieder beim ersten Sample und so weiter.","title":"Abspielen des Buffers"},{"location":"envs/","text":"H\u00fcllkurven (Envelopes) In der Audio-Terminologie bezeichnet der Begriff \"Envelope\" einen anpassbaren Parameter, der im Laufe der Zeit einen spezifischen Aspekt eines Klanges modifiziert. Envelope-Generatoren in Synthesizern werden dazu verwendet, das Verhalten eines Klangs w\u00e4hrend seiner Wiedergabe zu definieren. In SuperCollider erstellen wir eine H\u00fcllkurve mit der Klasse Env . Ein Env ben\u00f6tigt zwei wichtige Argumente: Zum einen die Zielwerte der einzelnen Segmente ( levels ) und zum anderen die Dauer, die jedes Segment haben sollte ( times ). Schauen wir uns eine solche einfache H\u00fcllkurve an: Env(levels: [0, 1, 0], times: [1, 1]).plot Diese H\u00fcllkurve generiert eine Reihe von Zahlen auf folgende Weise: Wir starten mit dem Wert 0 (auf der y-Achse dargestellt) zur Zeit 0 (Startzeit, auf der x-Achse dargestellt). Die H\u00fcllkurve erreicht den Wert 1 nach 1 Sekunde und kehrt innerhalb weiterer 1 Sekunde zum Wert 0 zur\u00fcck. Wir k\u00f6nnen die oben beschriebene H\u00fcllkurve nutzen, um den Klang unseres selbstgebauten Instruments (den wir bisher nur mit der free Methode oder durch Ctrl+. abgeschaltet haben) zeitlich und hinsichtlich der Lautst\u00e4rke zu modulieren. An dieser Stelle ist es wichtig zu beachten, dass die Klasse Env lediglich die Form unserer H\u00fcllkurve gestaltet. Um aus dieser einfachen Form einen H\u00fcllkurvengenerator f\u00fcr unsere Instrumente auf dem Server zu erstellen, m\u00fcssen wir die Form der H\u00fcllkurve an einen Envelope Generator senden. Dies geschieht mit der Klasse EnvGen (Envelope Generator), und wir schreiben dazu: EnvGen.kr(Env([0, 1, 0], [1, 1]), doneAction: 2); Anmerkung Das Argument doneAction des H\u00fcllkurvengenerators informiert den Server dar\u00fcber, dass der Speicherplatz f\u00fcr den Generator (und die damit verbundenen UGen) freigegeben werden soll, sobald die H\u00fcllkurve ihren Verlauf beendet hat. Wir integrieren diese H\u00fcllkurve in unser zuvor definiertes Instrument ( \\meinSynth ). Um den Lautst\u00e4rkenverlauf des Synthesizers zu beeinflussen, multiplizieren wir die Werte der H\u00fcllkurve mit den Ausgangswerten des Sinus-Oszillators: ( SynthDef(\\meinSynth, { arg freq=440, amp=0.2, kanal=0, dur=1; var halfDur = dur * 0.5; var env = EnvGen.kr(Env([0, amp, 0], [halfDur, halfDur]), doneAction: 2); Out.ar(kanal, SinOsc.ar(freq: freq, mul: env)) }).add ) Hier wird die H\u00fcllkurve auf die Gesamt-Amplitude des Synthesizers angewendet, um den Lautst\u00e4rkenverlauf zu gestalten. Der Sinus-Oszillator wird mit den skalierten Amplitudenwerten der H\u00fcllkurve moduliert. Beachten Sie, dass wir hier auch die Dauer unseres Instrumentenklangs eingef\u00fchrt haben, da diese jetzt mithilfe der H\u00fcllkurve sehr leicht bestimmbar ist! \u00dcbung Probieren Sie das neu gebaute Instrument mit unterschiedlichen Parametern aus. Beachten Sie, dass das Argument doneAction des H\u00fcllkurvengenerators ( EnvGen ) daf\u00fcr sorgt, dass der gesamte Synthesizer vom Server freigegeben wird, sobald die H\u00fcllkurve abgelaufen ist. Sie k\u00f6nnen dies unten rechts im Editor beobachten: \u00dcbung: Die Env -Klasse definiert eine Reihe von H\u00fcllkurvenformen wie sine , perc , triangle und linen . Schauen Sie sich diese Env-Methoden in der Dokumentation an. Setzen Sie diese Methoden in das Instrument ein und beobachten Sie den Unterschied. Versuchen Sie, dem Synthesizer Argumente zu geben, die Sie f\u00fcr diese Methoden verwenden k\u00f6nnen. Wenn man von H\u00fcllkurven spricht, assoziiert man sie oft mit den Abk\u00fcrzungen ADSR . Die sogenannte Attack-Decay-Sustain-Release-H\u00fcllkurve l\u00e4sst sich in SuperCollider leicht erzeugen. Dazu ben\u00f6tigen wir einen Anfangswert, einen H\u00f6chstwert (Peak), einen Sustain-Wert und einen Endwert: Env([0, 1, 0.5, 0.5, 0], [1, 1, 1, 1]).test.plot; \u00dcber das dritte Argument des Env k\u00f6nnen wir weitere Feineinstellungen in unserer H\u00fcllkurve vornehmen. Mit dem Argument curve k\u00f6nnen wir die Gestaltung einzelner Segmente beeinflussen. Dieses Argument kann entweder eine Zahl sein, wobei die Zahl 0 eine gerade Linie repr\u00e4sentiert, positive Zahlen eine Kr\u00fcmmung nach rechts und negative Zahlen eine Kr\u00fcmmung nach links darstellen. Je h\u00f6her die Zahl ist, desto st\u00e4rker wird die Kr\u00fcmmung des Segments sein: Env([0, 1, 0.5, 0.5, 0], [1, 1, 1, 1], curve: 5).test.plot Env([0, 1, 0.5, 0.5, 0], [1, 1, 1, 1], curve: -5).test.plot Wir haben auch die M\u00f6glichkeit, die Kr\u00fcmmung der Segmente unabh\u00e4ngig voneinander zu gestalten, indem wir sie in einem Array definieren: Env([0, 1, 0.5, 0.5, 0], [1, 1, 1, 1], curve: [5, -5, 0, 4.5]).test.plot Eine andere M\u00f6glichkeit, die Kr\u00fcmmung unserer H\u00fcllkurve zu bestimmen, besteht darin, eine der vordefinierten Formen (als Symbole) zu verwenden. Diese sind: \\step , \\hold , \\linear , \\exponential , \\sine , \\welch , \\squared oder \\cubed . \u00dcbung Schauen Sie sich die Definitionen dieser Kr\u00fcmmungsformen in der Dokumentation an. Setzen Sie diese Formen in das folgende Env ein und beurteilen Sie die Unterschiede im Klang: {Saw.ar(100, EnvGen.kr(Env([0.001, 0.5, 0.001], curve: ), doneAction: 2))}.play \u00dcbung Nutzen Sie die Iterationsm\u00f6glichkeiten, die wir im Kapitel Iteration mit Do und Collect gelernt haben, um einen C-Dur-Akkord mit dem neuen Instrument \\meinSynth abzuspielen.","title":"H\u00fcllkurven"},{"location":"envs/#hullkurven-envelopes","text":"In der Audio-Terminologie bezeichnet der Begriff \"Envelope\" einen anpassbaren Parameter, der im Laufe der Zeit einen spezifischen Aspekt eines Klanges modifiziert. Envelope-Generatoren in Synthesizern werden dazu verwendet, das Verhalten eines Klangs w\u00e4hrend seiner Wiedergabe zu definieren. In SuperCollider erstellen wir eine H\u00fcllkurve mit der Klasse Env . Ein Env ben\u00f6tigt zwei wichtige Argumente: Zum einen die Zielwerte der einzelnen Segmente ( levels ) und zum anderen die Dauer, die jedes Segment haben sollte ( times ). Schauen wir uns eine solche einfache H\u00fcllkurve an: Env(levels: [0, 1, 0], times: [1, 1]).plot Diese H\u00fcllkurve generiert eine Reihe von Zahlen auf folgende Weise: Wir starten mit dem Wert 0 (auf der y-Achse dargestellt) zur Zeit 0 (Startzeit, auf der x-Achse dargestellt). Die H\u00fcllkurve erreicht den Wert 1 nach 1 Sekunde und kehrt innerhalb weiterer 1 Sekunde zum Wert 0 zur\u00fcck. Wir k\u00f6nnen die oben beschriebene H\u00fcllkurve nutzen, um den Klang unseres selbstgebauten Instruments (den wir bisher nur mit der free Methode oder durch Ctrl+. abgeschaltet haben) zeitlich und hinsichtlich der Lautst\u00e4rke zu modulieren. An dieser Stelle ist es wichtig zu beachten, dass die Klasse Env lediglich die Form unserer H\u00fcllkurve gestaltet. Um aus dieser einfachen Form einen H\u00fcllkurvengenerator f\u00fcr unsere Instrumente auf dem Server zu erstellen, m\u00fcssen wir die Form der H\u00fcllkurve an einen Envelope Generator senden. Dies geschieht mit der Klasse EnvGen (Envelope Generator), und wir schreiben dazu: EnvGen.kr(Env([0, 1, 0], [1, 1]), doneAction: 2); Anmerkung Das Argument doneAction des H\u00fcllkurvengenerators informiert den Server dar\u00fcber, dass der Speicherplatz f\u00fcr den Generator (und die damit verbundenen UGen) freigegeben werden soll, sobald die H\u00fcllkurve ihren Verlauf beendet hat. Wir integrieren diese H\u00fcllkurve in unser zuvor definiertes Instrument ( \\meinSynth ). Um den Lautst\u00e4rkenverlauf des Synthesizers zu beeinflussen, multiplizieren wir die Werte der H\u00fcllkurve mit den Ausgangswerten des Sinus-Oszillators: ( SynthDef(\\meinSynth, { arg freq=440, amp=0.2, kanal=0, dur=1; var halfDur = dur * 0.5; var env = EnvGen.kr(Env([0, amp, 0], [halfDur, halfDur]), doneAction: 2); Out.ar(kanal, SinOsc.ar(freq: freq, mul: env)) }).add ) Hier wird die H\u00fcllkurve auf die Gesamt-Amplitude des Synthesizers angewendet, um den Lautst\u00e4rkenverlauf zu gestalten. Der Sinus-Oszillator wird mit den skalierten Amplitudenwerten der H\u00fcllkurve moduliert. Beachten Sie, dass wir hier auch die Dauer unseres Instrumentenklangs eingef\u00fchrt haben, da diese jetzt mithilfe der H\u00fcllkurve sehr leicht bestimmbar ist! \u00dcbung Probieren Sie das neu gebaute Instrument mit unterschiedlichen Parametern aus. Beachten Sie, dass das Argument doneAction des H\u00fcllkurvengenerators ( EnvGen ) daf\u00fcr sorgt, dass der gesamte Synthesizer vom Server freigegeben wird, sobald die H\u00fcllkurve abgelaufen ist. Sie k\u00f6nnen dies unten rechts im Editor beobachten: \u00dcbung: Die Env -Klasse definiert eine Reihe von H\u00fcllkurvenformen wie sine , perc , triangle und linen . Schauen Sie sich diese Env-Methoden in der Dokumentation an. Setzen Sie diese Methoden in das Instrument ein und beobachten Sie den Unterschied. Versuchen Sie, dem Synthesizer Argumente zu geben, die Sie f\u00fcr diese Methoden verwenden k\u00f6nnen. Wenn man von H\u00fcllkurven spricht, assoziiert man sie oft mit den Abk\u00fcrzungen ADSR . Die sogenannte Attack-Decay-Sustain-Release-H\u00fcllkurve l\u00e4sst sich in SuperCollider leicht erzeugen. Dazu ben\u00f6tigen wir einen Anfangswert, einen H\u00f6chstwert (Peak), einen Sustain-Wert und einen Endwert: Env([0, 1, 0.5, 0.5, 0], [1, 1, 1, 1]).test.plot; \u00dcber das dritte Argument des Env k\u00f6nnen wir weitere Feineinstellungen in unserer H\u00fcllkurve vornehmen. Mit dem Argument curve k\u00f6nnen wir die Gestaltung einzelner Segmente beeinflussen. Dieses Argument kann entweder eine Zahl sein, wobei die Zahl 0 eine gerade Linie repr\u00e4sentiert, positive Zahlen eine Kr\u00fcmmung nach rechts und negative Zahlen eine Kr\u00fcmmung nach links darstellen. Je h\u00f6her die Zahl ist, desto st\u00e4rker wird die Kr\u00fcmmung des Segments sein: Env([0, 1, 0.5, 0.5, 0], [1, 1, 1, 1], curve: 5).test.plot Env([0, 1, 0.5, 0.5, 0], [1, 1, 1, 1], curve: -5).test.plot Wir haben auch die M\u00f6glichkeit, die Kr\u00fcmmung der Segmente unabh\u00e4ngig voneinander zu gestalten, indem wir sie in einem Array definieren: Env([0, 1, 0.5, 0.5, 0], [1, 1, 1, 1], curve: [5, -5, 0, 4.5]).test.plot Eine andere M\u00f6glichkeit, die Kr\u00fcmmung unserer H\u00fcllkurve zu bestimmen, besteht darin, eine der vordefinierten Formen (als Symbole) zu verwenden. Diese sind: \\step , \\hold , \\linear , \\exponential , \\sine , \\welch , \\squared oder \\cubed . \u00dcbung Schauen Sie sich die Definitionen dieser Kr\u00fcmmungsformen in der Dokumentation an. Setzen Sie diese Formen in das folgende Env ein und beurteilen Sie die Unterschiede im Klang: {Saw.ar(100, EnvGen.kr(Env([0.001, 0.5, 0.001], curve: ), doneAction: 2))}.play \u00dcbung Nutzen Sie die Iterationsm\u00f6glichkeiten, die wir im Kapitel Iteration mit Do und Collect gelernt haben, um einen C-Dur-Akkord mit dem neuen Instrument \\meinSynth abzuspielen.","title":"H\u00fcllkurven (Envelopes)"},{"location":"first_sounds/","text":"Die ersten T\u00f6ne Starten des Servers Im letzten Kapitel haben wir uns mit der Sprache SuperCollider besch\u00e4ftigt. Die Sprache allein kann keinen Klang erzeugen, sondern ist lediglich f\u00fcr die Weitergabe unserer Befehle an den Klang-Server verantwortlich. Um unseren ersten Ton in SuperCollider zu erzeugen, m\u00fcssen wir zuerst den Server starten. Erinnern wir uns daran, dass die Einzelvariabel \"s\" f\u00fcr den Server steht. Mit dem Aufrufen des boot -Befehls starten wir ihn: s.boot; Der Klang der Sinusschwingung ( Hello World! ) Aus historischen Gr\u00fcnden werden in SuperCollider auch die Objekte, die f\u00fcr die Klangerzeugung verantwortlich sind, als \"UGen\" bezeichnet. Eine dieser UGens ist SinOsc, die eine einfache Sinusschwingung generiert (Ein sch\u00f6ner (und historischer) Artikel bez\u00fcglich des Sinustons von Herbert Eimert ist hier verlinkt). Die meisten UGens in SuperCollider ben\u00f6tigen Informationen von uns (\u00e4hnlich wie Argumente in Funktionen im letzten Kapitel). Zum Beispiel ben\u00f6tigt unser SinOsc UGen folgende Eingaben: Frequenz, Phase, Amplitude und DC-Offset. Geben Sie den folgenden Code in Ihren SuperCollider-Editor ein. Sobald Sie die Klammer \u00f6ffnen, sollten Sie diese Argumente sehen k\u00f6nnen. Achten Sie darauf, dass diese Argumente auch Standardwerte haben, so dass, wenn wir keine Informationen bereitstellen, diese Standardwerte \u00fcbernommen werden: SinOsc.ar(); (Tipp: Wenn die Argumentenliste nicht angezeigt wird, kann man sie durch Dr\u00fccken der Tastenkombination Shift+Ctrl+L wieder einblenden.) Im Kontext von SuperCollider steuern die Argumente des SinOsc (Sinus Oszillator) die Eigenschaften der erzeugten Sinusschwingung. Hier sind die Argumente: Frequenz (freq): Dies bestimmt, wie viele Schwingungen pro Sekunde erzeugt werden. Eine h\u00f6here Frequenz erzeugt einen h\u00f6heren Ton. Phase (phase): Die Phase gibt den Startpunkt der Sinusschwingung an. Eine Phase von 0 bedeutet, dass die Schwingung bei null Grad beginnt. Amplitude (mul): Die Amplitude beeinflusst die H\u00f6he der Schwingung und damit die Lautst\u00e4rke des Tons. Eine h\u00f6here Amplitude erzeugt einen lauter klingenden Ton (Werte zwischen 0 und 1). DC-Offset (add): Dies ist eine konstante Spannung, die zur Sinuswelle hinzugef\u00fcgt wird. Sie beeinflusst den Grundpegel der Welle und kann dazu verwendet werden, sicherzustellen, dass die Welle um den Nullpunkt zentriert ist oder einen bestimmten Ausgangspunkt hat. Der Code SinOsc.ar() erzeugt standardm\u00e4\u00dfig eine Sinusschwingung mit den Standardwerten f\u00fcr Frequenz, Phase, Amplitude und DC-Offset. Wenn Sie spezifische Werte angeben m\u00f6chten, k\u00f6nnen Sie sie als Argumente im SinOsc-Objekt setzen, z.B. SinOsc.ar(440, 0, 0.5, 0) , wobei 440 die Frequenz, 0 die Phase, 0.5 die Amplitude und 0 das DC-Offset ist. Um nun den Klang einer 440-Hz-Frequenz zu h\u00f6ren, m\u00fcssen wir unsere UGens in eine Funktion einbetten und die play -Nachricht an diese Funktion senden. Dadurch wird die enthaltene UGen an den Server gesendet, und wir k\u00f6nnen etwas h\u00f6ren. Bevor wir weitermachen und den ersten Sinuston an den Server senden, ist es wichtig zu wissen, wie wir den Ton wieder ausschalten k\u00f6nnen. Merken Sie sich die Tastenkombination Ctrl+. Dies deaktiviert den Server, und wir nutzen momentan diese Methode, um den Ton schnell auszuschalten. Schreiben Sie nun den folgenden Code-Block und f\u00fchren Sie ihn aus (mit dem Cursor innerhalb des Blocks Ctrl+Enter dr\u00fccken): {SinOsc.ar(440, 0, 0.5, 0)}.play; Stoppen Sie den Server mit Ctrl+. und lassen Sie uns den obigen Code etwas genauer betrachten. Wir \u00f6ffnen zuerst mit den runden Klammern einen Block. Dies ist praktisch, wenn unser Code \u00fcber mehrere Zeilen geht, damit wir alle Zeilen auf einmal auswerten k\u00f6nnen. () Als N\u00e4chstes \u00f6ffnen wir ein paar geschweifte Klammern, um eine anonyme Funktion zu definieren. Sie ist anonym, weil wir diese Funktion nur an dieser Stelle als Beispiel verwenden und ihr keinen Namen geben: ({}) Innerhalb unserer Funktion schreiben wir unsere UGen mit den gew\u00fcnschten Argumenten: ({SinOsc.ar(440, 0, 0.5, 0)}) Auf das Objekt SinOsc wenden wir die Nachricht ar an, die f\u00fcr Audio Rate steht. Die ar -Funktion sorgt daf\u00fcr, dass die Sample-Ausgaben der UGen (hier SinOsc) in einer Audiorate (oft 44100 Mal pro Sekunde) vom Server an die Audiokarten unseres Rechners geschickt werden. Von dort werden diese Samples (die im Prinzip nichts anderes sind als Dezimalzahlen) an einen sogenannten DAC (Digital Audio Converter) geschickt, um dann als Spannungsvariationen (nach eventueller Verst\u00e4rkung) an Lautsprecher gesendet zu werden. Wichtig ist auch zu verstehen, dass die ar -Methode gleichzeitig eine Instanz der SinOsc-Klasse generiert. Wenn wir an dieser Stelle unseren Code-Block auswerten, sehen wir im Post-Fenster, dass er zu einer Funktion evaluiert wurde ( -> a Function ). Jetzt k\u00f6nnen wir unsere Funktion an den Server senden. Daf\u00fcr rufen wir die play -Methode auf die Funktion auf. Was wir hier \u00fcber die play -Methode einer Funktion wissen m\u00fcssen: play generiert auf dem Server einen sogenannten Synth. Synths sind die Klanggeneratoren auf der Server-Seite. Diese Synth wird nach der Erstellung zum Klingen gebracht: ({SinOsc.ar(440, 0, 0.5, 0)}.play) Wenn wir die tats\u00e4chliche Synth, die f\u00fcr uns von play generiert wurde, weiterhin kontrollieren m\u00f6chten (der serverinterne Name wird im Post-Fenster nach dem Auswerten der obigen Zeile angezeigt), k\u00f6nnen wir ganz einfach die ausgegebene Synth einer Variable zuweisen: (x = {SinOsc.ar(440, 0, 0.5, 0)}.play) Jetzt enth\u00e4lt x die Synth, und wir k\u00f6nnen sie zum Beispiel \u00fcber die Variable x ausschalten, indem wir der Variable x die Nachricht free senden: x.free; Das ist praktisch, da wir mit free nur diese eine Synth-Instanz abschalten k\u00f6nnen (im Unterschied zu unserer vorherigen L\u00f6sung Ctrl+. , die den kompletten Server herunterf\u00e4hrt). Wir k\u00f6nnen unserer Funktion Argumente hinzuf\u00fcgen, sodass wir die Parameter unseres SinOsc explizit eingeben k\u00f6nnen: ( x = { arg freq = 100, amp = 0.5; SinOsc.ar(freq, mul: amp) } ) So k\u00f6nnen wir durch die set -Methode unserer Synth-Instanzen die Frequenz oder die Amplitude neu setzen, und das w\u00e4hrend der Synth l\u00e4uft (also w\u00e4hrend unser Sinuston weiter erklingt): // Wir k\u00f6nnen uns den Plot unserer Funktion ansehen // (f\u00fcr 0.1 Sekunden, was mit unserer Funktionsfrequenz von 100 Hz 10 Schwingungsperioden entspricht) x.plot(0.1); \u00dcbung: Versuchen Sie, verschiedene Parameter einer Funktion mit einer Sinus-Schwingung zu ver\u00e4ndern (z.B. Phase, Amplitude, Offset) und verfolgen Sie die Unterschiede im resultierenden Plot. // Funktion abspielen // Den resultierenden Prozess in einer Variablen speichern y = x.play; // Amplitude halbieren y.set(\\amp, 0.25); // Die Frequenz um eine Oktave tiefer spielen y.set(\\freq, 220); // Und den Prozess ausschalten y.free; Verschachtelung der UGens Das Verst\u00e4ndnis eines Prinzips ist hier von Bedeutung: auch die UGens (wie alles andere auf unserem Rechner!) arbeiten ausschlie\u00dflich mit Zahlen! Das bedeutet, ihre Ausgabe besteht ausschlie\u00dflich aus Zahlen. Wenn wir in eine Sinusschwingung in einem DAW-Programm (hier Audacity ) ausreichend hineinzoomen, k\u00f6nnen wir die einzelnen Sample-Werte (die Amplitudenwerte unseres Sinustons, Dezimalzahlen) sehen: Da die UGens schlie\u00dflich nur Zahlen ausgeben, k\u00f6nnen wir s\u00e4mtliche mathematische Funktionen, die wir auf Zahlen anwenden k\u00f6nnen, auch auf UGens anwenden. Schauen Sie sich das folgende Beispiel an und erkl\u00e4ren Sie, was Sie im Post-Fenster sehen: {(SinOsc.ar(1).poll(label: \\Sin) * 10).poll(label: \\SinX10)}.play Diese Eigenschaft der UGens erm\u00f6glicht es uns, eine weitere UGen als Argument f\u00fcr unsere SinOsc UGen einzusetzen. Dadurch wird ein kontinuierlicher Datenstrom an Zahlen an die Haupt-UGen gesendet, die dann als Frequenz (oder auch andere Parameter) interpretiert werden k\u00f6nnen. Ein Beispiel: ( { SinOsc.ar(SinOsc.kr(1, mul: 100, add: 400)) }.play ) Dieses Beispiel demonstriert, wie eine Sinus-Oszillation (SinOsc) mit einer anderen Sinus-Oszillation als Modulator f\u00fcr ihre Frequenz verwendet werden kann. Lassen Sie uns dieses Beispiel etwas genauer unter die Lupe nehmen: Das innere SinOsc fungiert hier als Frequenzmodulator. Ein SinOsc generiert Dezimalzahlen zwischen -1 und 1 mit einer bestimmten Frequenz. Diese Zahlen werden mit 100 multipliziert, um den Bereich auf -100 bis 100 zu skalieren. Danach wird 400 dazu addiert, um den Wertebereich zu verschieben. Dies f\u00fchrt zu einem Glissando-Effekt im Bereich zwischen 300 Hz und 500 Hz (Achtung: die Multiplikation erfolgt vor der Addition). Das gleiche Ergebnis kann durch Senden der Nachricht range an den Zahlenstrom des inneren SinOsc mit den Argumenten 300 und 500 erreicht werden (Mit dem Cursor auf dem Wort \"range\" dr\u00fccken Sie die Tastenkombination Ctrl+D , um die Dokumentationsseite \u00fcber range zu \u00f6ffnen. Dort k\u00f6nnen Sie unter verschiedenen Eintr\u00e4gen auf UGen klicken, um weitere Informationen \u00fcber range zu erhalten): ( { SinOsc.ar(SinOsc.kr(1).range(300, 500) * 100 + 400) }.play; ) \u00dcbung: LFO-Modulation der Frequenz Modulieren Sie die Frequenz eines Sinus-Oszillators mit einem LFO (Low-Frequency Oscillator) im Bereich 100 Hz - 300 Hz. Sie d\u00fcrfen die Frequenz des LFO bestimmen. Verwenden Sie einen LFO um unterschiedliche Parameter einesOszillators zu modulieren. Mehrkanal-Erweiterung Viele UGens in SuperCollider unterst\u00fctzen eine Eigenschaft namens Multiple Dispatching . Was dies vereinfacht bedeutet, ist, dass das Verhalten der UGens je nach Typ ihrer Argumente unterschiedlich sein wird. Zum Beispiel k\u00f6nnen wir einem Sinus-Oszillator nicht nur eine Zahl als Argument f\u00fcr einen seiner Parameter angeben, sondern auch ein Array von Zahlen. Was dann passiert, ist, dass SuperCollider die Angabe des Arrays als Argument interpretiert, als eine Liste von Ausg\u00e4ngen (z.B. eine Liste von Lautsprechern), und generiert so viele Signale wie die Gr\u00f6\u00dfe des Arrays und sendet sie an die Lautsprecher. Schauen wir uns dazu ein Beispiel an, indem wir ein Signal-Array vom selben Sinus-Oszillator mit unterschiedlichen Amplituden generieren. Dazu betrachten wir den sogenannten \"Server Meter\", der uns die Signalwege In und Out vom SuperCollider-Server anzeigt. Dr\u00fccken Sie die Tastenkombination Ctrl-M oder klicken Sie im Editor unter dem Server-Menu auf Server > Show Server Meter . Jetzt evaluieren Sie folgenden Code: ( { SinOsc.ar(200, mul: [0.01, 0.3]) }.play; ) \u00dcbung: Beschreibung Erkl\u00e4ren Sie, was Sie im Server Meter sehen, und den Grund daf\u00fcr. \u00dcbung: Simulation des Klanges einer Klarinette L\u00f6sung Die vollst\u00e4ndige harmonische Reihe besteht aus den Frequenzen f0, 2 x f0, 3 x f0, 4 x f0, 5 x f0 usw., wobei f0 die Grundfrequenz ist. Die Klarinette spielt (ungef\u00e4hr) nur die ungeraden Mitglieder der Serie. Simulieren Sie den Klang einer Klarinette mit einem einzigen SinOsc und einem Array f\u00fcr die freq - und mul -Argumente. Verwenden Sie zunehmend kleinere Werte f\u00fcr die Amplitude h\u00f6herer Teilt\u00f6ne des Klangs. Tipp: Dies l\u00e4sst sich sehr einfach mit den Array-Klassenmethoden series und geom implementieren. Da wir im Grunde genommen mehrere Instanzen des SinOsc -UGen erzeugen, indem wir Arrays \u00fcbergeben, k\u00f6nnen wir mithilfe der Mix -Klasse dieses End-Array in ein Stereosignal (ein Array mit zwei Elementen) zusammenfassen ( Mix erzeugt die Summe aller Signale in seinem Argument; suchen Sie mit Ctrl+Shift+D nach der Dokumentationsseite: Mix ). \u00dcbung: Generierung eines Intervals Generieren Sie ein Quint-Intervall mit den beiden T\u00f6nen A (440 Hz) und der Quinte dar\u00fcber. Senden Sie an Ihre Funktion statt play die Nachricht value , um die Funktion zu evaluieren, anstatt den Ausgabewert an den Server f\u00fcr Klanggenerierung zu leiten. Die Ausgabe ist ein Array von UGens. Beachten Sie, dass es in diesem Kontext ausreicht, wenn eines der Argumente anstelle einer Zahl ein Array ist, um eine entsprechende Array von Ausg\u00e4ngen zur\u00fcckzubekommen. Wenn ein Array mit 2 Zahlen als Argument an unsere UGen \u00fcbergeben wird, resultiert dies in einem Array mit zwei Kopien derselben UGen. Achten Sie darauf, dass das Ergebnis des obigen Codes exakt gleich dem unteren ist: ( { var sig = SinOsc.ar(200); // Das Signal als ein Array an den Server senden. // Der Server wird dann die Signale in einem Array an // physikalischen Ausg\u00e4ngen (Lautsprechern) abbilden, // so dass das erste Signal am Lautsprecher 1, das // zweite am Lautsprecher 2 usw. gesendet wird. [sig * 0.01, sig * 0.3] }.play; ) Fazit: Der Server interpretiert ein Array als Mehrkanalklang. Es gibt verschiedene syntaktische M\u00f6glichkeiten, UGens zu vervielf\u00e4ltigen. Einige dieser M\u00f6glichkeiten sind hier aufgelistet: Die dup Funktion erh\u00e4lt zwei Argumente: ein Element und die Anzahl, wie oft dieses Element vervielf\u00e4ltigt werden soll (nennen wir diese Anzahl N). Sie gibt ein N-Tuple-Array mit Kopien des Elements zur\u00fcck: \"Ein String\".dup() // -> [ EinString, EinString ] SinOsc.ar.dup(2) // -> [ SinOsc, SinOsc ] Eine alternative Schreibweise f\u00fcr dup ist der Duplizierungsoperator ! : \"Ein String\" ! 2 // -> [ EinString, EinString ] SinOsc.ar ! 2 // -> [ SinOsc, SinOsc ]","title":"Die ersten T\u00f6ne"},{"location":"first_sounds/#die-ersten-tone","text":"","title":"Die ersten T\u00f6ne"},{"location":"first_sounds/#starten-des-servers","text":"Im letzten Kapitel haben wir uns mit der Sprache SuperCollider besch\u00e4ftigt. Die Sprache allein kann keinen Klang erzeugen, sondern ist lediglich f\u00fcr die Weitergabe unserer Befehle an den Klang-Server verantwortlich. Um unseren ersten Ton in SuperCollider zu erzeugen, m\u00fcssen wir zuerst den Server starten. Erinnern wir uns daran, dass die Einzelvariabel \"s\" f\u00fcr den Server steht. Mit dem Aufrufen des boot -Befehls starten wir ihn: s.boot;","title":"Starten des Servers"},{"location":"first_sounds/#der-klang-der-sinusschwingung-hello-world","text":"Aus historischen Gr\u00fcnden werden in SuperCollider auch die Objekte, die f\u00fcr die Klangerzeugung verantwortlich sind, als \"UGen\" bezeichnet. Eine dieser UGens ist SinOsc, die eine einfache Sinusschwingung generiert (Ein sch\u00f6ner (und historischer) Artikel bez\u00fcglich des Sinustons von Herbert Eimert ist hier verlinkt). Die meisten UGens in SuperCollider ben\u00f6tigen Informationen von uns (\u00e4hnlich wie Argumente in Funktionen im letzten Kapitel). Zum Beispiel ben\u00f6tigt unser SinOsc UGen folgende Eingaben: Frequenz, Phase, Amplitude und DC-Offset. Geben Sie den folgenden Code in Ihren SuperCollider-Editor ein. Sobald Sie die Klammer \u00f6ffnen, sollten Sie diese Argumente sehen k\u00f6nnen. Achten Sie darauf, dass diese Argumente auch Standardwerte haben, so dass, wenn wir keine Informationen bereitstellen, diese Standardwerte \u00fcbernommen werden: SinOsc.ar(); (Tipp: Wenn die Argumentenliste nicht angezeigt wird, kann man sie durch Dr\u00fccken der Tastenkombination Shift+Ctrl+L wieder einblenden.) Im Kontext von SuperCollider steuern die Argumente des SinOsc (Sinus Oszillator) die Eigenschaften der erzeugten Sinusschwingung. Hier sind die Argumente: Frequenz (freq): Dies bestimmt, wie viele Schwingungen pro Sekunde erzeugt werden. Eine h\u00f6here Frequenz erzeugt einen h\u00f6heren Ton. Phase (phase): Die Phase gibt den Startpunkt der Sinusschwingung an. Eine Phase von 0 bedeutet, dass die Schwingung bei null Grad beginnt. Amplitude (mul): Die Amplitude beeinflusst die H\u00f6he der Schwingung und damit die Lautst\u00e4rke des Tons. Eine h\u00f6here Amplitude erzeugt einen lauter klingenden Ton (Werte zwischen 0 und 1). DC-Offset (add): Dies ist eine konstante Spannung, die zur Sinuswelle hinzugef\u00fcgt wird. Sie beeinflusst den Grundpegel der Welle und kann dazu verwendet werden, sicherzustellen, dass die Welle um den Nullpunkt zentriert ist oder einen bestimmten Ausgangspunkt hat. Der Code SinOsc.ar() erzeugt standardm\u00e4\u00dfig eine Sinusschwingung mit den Standardwerten f\u00fcr Frequenz, Phase, Amplitude und DC-Offset. Wenn Sie spezifische Werte angeben m\u00f6chten, k\u00f6nnen Sie sie als Argumente im SinOsc-Objekt setzen, z.B. SinOsc.ar(440, 0, 0.5, 0) , wobei 440 die Frequenz, 0 die Phase, 0.5 die Amplitude und 0 das DC-Offset ist. Um nun den Klang einer 440-Hz-Frequenz zu h\u00f6ren, m\u00fcssen wir unsere UGens in eine Funktion einbetten und die play -Nachricht an diese Funktion senden. Dadurch wird die enthaltene UGen an den Server gesendet, und wir k\u00f6nnen etwas h\u00f6ren. Bevor wir weitermachen und den ersten Sinuston an den Server senden, ist es wichtig zu wissen, wie wir den Ton wieder ausschalten k\u00f6nnen. Merken Sie sich die Tastenkombination Ctrl+. Dies deaktiviert den Server, und wir nutzen momentan diese Methode, um den Ton schnell auszuschalten. Schreiben Sie nun den folgenden Code-Block und f\u00fchren Sie ihn aus (mit dem Cursor innerhalb des Blocks Ctrl+Enter dr\u00fccken): {SinOsc.ar(440, 0, 0.5, 0)}.play; Stoppen Sie den Server mit Ctrl+. und lassen Sie uns den obigen Code etwas genauer betrachten. Wir \u00f6ffnen zuerst mit den runden Klammern einen Block. Dies ist praktisch, wenn unser Code \u00fcber mehrere Zeilen geht, damit wir alle Zeilen auf einmal auswerten k\u00f6nnen. () Als N\u00e4chstes \u00f6ffnen wir ein paar geschweifte Klammern, um eine anonyme Funktion zu definieren. Sie ist anonym, weil wir diese Funktion nur an dieser Stelle als Beispiel verwenden und ihr keinen Namen geben: ({}) Innerhalb unserer Funktion schreiben wir unsere UGen mit den gew\u00fcnschten Argumenten: ({SinOsc.ar(440, 0, 0.5, 0)}) Auf das Objekt SinOsc wenden wir die Nachricht ar an, die f\u00fcr Audio Rate steht. Die ar -Funktion sorgt daf\u00fcr, dass die Sample-Ausgaben der UGen (hier SinOsc) in einer Audiorate (oft 44100 Mal pro Sekunde) vom Server an die Audiokarten unseres Rechners geschickt werden. Von dort werden diese Samples (die im Prinzip nichts anderes sind als Dezimalzahlen) an einen sogenannten DAC (Digital Audio Converter) geschickt, um dann als Spannungsvariationen (nach eventueller Verst\u00e4rkung) an Lautsprecher gesendet zu werden. Wichtig ist auch zu verstehen, dass die ar -Methode gleichzeitig eine Instanz der SinOsc-Klasse generiert. Wenn wir an dieser Stelle unseren Code-Block auswerten, sehen wir im Post-Fenster, dass er zu einer Funktion evaluiert wurde ( -> a Function ). Jetzt k\u00f6nnen wir unsere Funktion an den Server senden. Daf\u00fcr rufen wir die play -Methode auf die Funktion auf. Was wir hier \u00fcber die play -Methode einer Funktion wissen m\u00fcssen: play generiert auf dem Server einen sogenannten Synth. Synths sind die Klanggeneratoren auf der Server-Seite. Diese Synth wird nach der Erstellung zum Klingen gebracht: ({SinOsc.ar(440, 0, 0.5, 0)}.play) Wenn wir die tats\u00e4chliche Synth, die f\u00fcr uns von play generiert wurde, weiterhin kontrollieren m\u00f6chten (der serverinterne Name wird im Post-Fenster nach dem Auswerten der obigen Zeile angezeigt), k\u00f6nnen wir ganz einfach die ausgegebene Synth einer Variable zuweisen: (x = {SinOsc.ar(440, 0, 0.5, 0)}.play) Jetzt enth\u00e4lt x die Synth, und wir k\u00f6nnen sie zum Beispiel \u00fcber die Variable x ausschalten, indem wir der Variable x die Nachricht free senden: x.free; Das ist praktisch, da wir mit free nur diese eine Synth-Instanz abschalten k\u00f6nnen (im Unterschied zu unserer vorherigen L\u00f6sung Ctrl+. , die den kompletten Server herunterf\u00e4hrt). Wir k\u00f6nnen unserer Funktion Argumente hinzuf\u00fcgen, sodass wir die Parameter unseres SinOsc explizit eingeben k\u00f6nnen: ( x = { arg freq = 100, amp = 0.5; SinOsc.ar(freq, mul: amp) } ) So k\u00f6nnen wir durch die set -Methode unserer Synth-Instanzen die Frequenz oder die Amplitude neu setzen, und das w\u00e4hrend der Synth l\u00e4uft (also w\u00e4hrend unser Sinuston weiter erklingt): // Wir k\u00f6nnen uns den Plot unserer Funktion ansehen // (f\u00fcr 0.1 Sekunden, was mit unserer Funktionsfrequenz von 100 Hz 10 Schwingungsperioden entspricht) x.plot(0.1); \u00dcbung: Versuchen Sie, verschiedene Parameter einer Funktion mit einer Sinus-Schwingung zu ver\u00e4ndern (z.B. Phase, Amplitude, Offset) und verfolgen Sie die Unterschiede im resultierenden Plot. // Funktion abspielen // Den resultierenden Prozess in einer Variablen speichern y = x.play; // Amplitude halbieren y.set(\\amp, 0.25); // Die Frequenz um eine Oktave tiefer spielen y.set(\\freq, 220); // Und den Prozess ausschalten y.free;","title":"Der Klang der Sinusschwingung (Hello World!)"},{"location":"first_sounds/#verschachtelung-der-ugens","text":"Das Verst\u00e4ndnis eines Prinzips ist hier von Bedeutung: auch die UGens (wie alles andere auf unserem Rechner!) arbeiten ausschlie\u00dflich mit Zahlen! Das bedeutet, ihre Ausgabe besteht ausschlie\u00dflich aus Zahlen. Wenn wir in eine Sinusschwingung in einem DAW-Programm (hier Audacity ) ausreichend hineinzoomen, k\u00f6nnen wir die einzelnen Sample-Werte (die Amplitudenwerte unseres Sinustons, Dezimalzahlen) sehen: Da die UGens schlie\u00dflich nur Zahlen ausgeben, k\u00f6nnen wir s\u00e4mtliche mathematische Funktionen, die wir auf Zahlen anwenden k\u00f6nnen, auch auf UGens anwenden. Schauen Sie sich das folgende Beispiel an und erkl\u00e4ren Sie, was Sie im Post-Fenster sehen: {(SinOsc.ar(1).poll(label: \\Sin) * 10).poll(label: \\SinX10)}.play Diese Eigenschaft der UGens erm\u00f6glicht es uns, eine weitere UGen als Argument f\u00fcr unsere SinOsc UGen einzusetzen. Dadurch wird ein kontinuierlicher Datenstrom an Zahlen an die Haupt-UGen gesendet, die dann als Frequenz (oder auch andere Parameter) interpretiert werden k\u00f6nnen. Ein Beispiel: ( { SinOsc.ar(SinOsc.kr(1, mul: 100, add: 400)) }.play ) Dieses Beispiel demonstriert, wie eine Sinus-Oszillation (SinOsc) mit einer anderen Sinus-Oszillation als Modulator f\u00fcr ihre Frequenz verwendet werden kann. Lassen Sie uns dieses Beispiel etwas genauer unter die Lupe nehmen: Das innere SinOsc fungiert hier als Frequenzmodulator. Ein SinOsc generiert Dezimalzahlen zwischen -1 und 1 mit einer bestimmten Frequenz. Diese Zahlen werden mit 100 multipliziert, um den Bereich auf -100 bis 100 zu skalieren. Danach wird 400 dazu addiert, um den Wertebereich zu verschieben. Dies f\u00fchrt zu einem Glissando-Effekt im Bereich zwischen 300 Hz und 500 Hz (Achtung: die Multiplikation erfolgt vor der Addition). Das gleiche Ergebnis kann durch Senden der Nachricht range an den Zahlenstrom des inneren SinOsc mit den Argumenten 300 und 500 erreicht werden (Mit dem Cursor auf dem Wort \"range\" dr\u00fccken Sie die Tastenkombination Ctrl+D , um die Dokumentationsseite \u00fcber range zu \u00f6ffnen. Dort k\u00f6nnen Sie unter verschiedenen Eintr\u00e4gen auf UGen klicken, um weitere Informationen \u00fcber range zu erhalten): ( { SinOsc.ar(SinOsc.kr(1).range(300, 500) * 100 + 400) }.play; ) \u00dcbung: LFO-Modulation der Frequenz Modulieren Sie die Frequenz eines Sinus-Oszillators mit einem LFO (Low-Frequency Oscillator) im Bereich 100 Hz - 300 Hz. Sie d\u00fcrfen die Frequenz des LFO bestimmen. Verwenden Sie einen LFO um unterschiedliche Parameter einesOszillators zu modulieren.","title":"Verschachtelung der UGens"},{"location":"first_sounds/#mehrkanal-erweiterung","text":"Viele UGens in SuperCollider unterst\u00fctzen eine Eigenschaft namens Multiple Dispatching . Was dies vereinfacht bedeutet, ist, dass das Verhalten der UGens je nach Typ ihrer Argumente unterschiedlich sein wird. Zum Beispiel k\u00f6nnen wir einem Sinus-Oszillator nicht nur eine Zahl als Argument f\u00fcr einen seiner Parameter angeben, sondern auch ein Array von Zahlen. Was dann passiert, ist, dass SuperCollider die Angabe des Arrays als Argument interpretiert, als eine Liste von Ausg\u00e4ngen (z.B. eine Liste von Lautsprechern), und generiert so viele Signale wie die Gr\u00f6\u00dfe des Arrays und sendet sie an die Lautsprecher. Schauen wir uns dazu ein Beispiel an, indem wir ein Signal-Array vom selben Sinus-Oszillator mit unterschiedlichen Amplituden generieren. Dazu betrachten wir den sogenannten \"Server Meter\", der uns die Signalwege In und Out vom SuperCollider-Server anzeigt. Dr\u00fccken Sie die Tastenkombination Ctrl-M oder klicken Sie im Editor unter dem Server-Menu auf Server > Show Server Meter . Jetzt evaluieren Sie folgenden Code: ( { SinOsc.ar(200, mul: [0.01, 0.3]) }.play; ) \u00dcbung: Beschreibung Erkl\u00e4ren Sie, was Sie im Server Meter sehen, und den Grund daf\u00fcr. \u00dcbung: Simulation des Klanges einer Klarinette L\u00f6sung Die vollst\u00e4ndige harmonische Reihe besteht aus den Frequenzen f0, 2 x f0, 3 x f0, 4 x f0, 5 x f0 usw., wobei f0 die Grundfrequenz ist. Die Klarinette spielt (ungef\u00e4hr) nur die ungeraden Mitglieder der Serie. Simulieren Sie den Klang einer Klarinette mit einem einzigen SinOsc und einem Array f\u00fcr die freq - und mul -Argumente. Verwenden Sie zunehmend kleinere Werte f\u00fcr die Amplitude h\u00f6herer Teilt\u00f6ne des Klangs. Tipp: Dies l\u00e4sst sich sehr einfach mit den Array-Klassenmethoden series und geom implementieren. Da wir im Grunde genommen mehrere Instanzen des SinOsc -UGen erzeugen, indem wir Arrays \u00fcbergeben, k\u00f6nnen wir mithilfe der Mix -Klasse dieses End-Array in ein Stereosignal (ein Array mit zwei Elementen) zusammenfassen ( Mix erzeugt die Summe aller Signale in seinem Argument; suchen Sie mit Ctrl+Shift+D nach der Dokumentationsseite: Mix ). \u00dcbung: Generierung eines Intervals Generieren Sie ein Quint-Intervall mit den beiden T\u00f6nen A (440 Hz) und der Quinte dar\u00fcber. Senden Sie an Ihre Funktion statt play die Nachricht value , um die Funktion zu evaluieren, anstatt den Ausgabewert an den Server f\u00fcr Klanggenerierung zu leiten. Die Ausgabe ist ein Array von UGens. Beachten Sie, dass es in diesem Kontext ausreicht, wenn eines der Argumente anstelle einer Zahl ein Array ist, um eine entsprechende Array von Ausg\u00e4ngen zur\u00fcckzubekommen. Wenn ein Array mit 2 Zahlen als Argument an unsere UGen \u00fcbergeben wird, resultiert dies in einem Array mit zwei Kopien derselben UGen. Achten Sie darauf, dass das Ergebnis des obigen Codes exakt gleich dem unteren ist: ( { var sig = SinOsc.ar(200); // Das Signal als ein Array an den Server senden. // Der Server wird dann die Signale in einem Array an // physikalischen Ausg\u00e4ngen (Lautsprechern) abbilden, // so dass das erste Signal am Lautsprecher 1, das // zweite am Lautsprecher 2 usw. gesendet wird. [sig * 0.01, sig * 0.3] }.play; ) Fazit: Der Server interpretiert ein Array als Mehrkanalklang. Es gibt verschiedene syntaktische M\u00f6glichkeiten, UGens zu vervielf\u00e4ltigen. Einige dieser M\u00f6glichkeiten sind hier aufgelistet: Die dup Funktion erh\u00e4lt zwei Argumente: ein Element und die Anzahl, wie oft dieses Element vervielf\u00e4ltigt werden soll (nennen wir diese Anzahl N). Sie gibt ein N-Tuple-Array mit Kopien des Elements zur\u00fcck: \"Ein String\".dup() // -> [ EinString, EinString ] SinOsc.ar.dup(2) // -> [ SinOsc, SinOsc ] Eine alternative Schreibweise f\u00fcr dup ist der Duplizierungsoperator ! : \"Ein String\" ! 2 // -> [ EinString, EinString ] SinOsc.ar ! 2 // -> [ SinOsc, SinOsc ]","title":"Mehrkanal-Erweiterung"},{"location":"kontakt/","text":"Kontakt Amir.Teymuri[at]hmtm.de","title":"Kontakt"},{"location":"kontakt/#kontakt","text":"Amir.Teymuri[at]hmtm.de","title":"Kontakt"},{"location":"lang/","text":"Einf\u00fchrung in die Sprache SuperCollider Namengebung In der Programmierung (f\u00fcr uns Menschen) ist es allgemein einfacher, sich Namen anstelle von komplexen Daten zu merken. Daher k\u00f6nnen wir in unserem Code Namen f\u00fcr unsere Daten zuweisen. Es gibt drei M\u00f6glichkeiten Namen zu definieren: Einzellige Namen Hierf\u00fcr verwenden wir einzelne Kleinbuchstaben, wie folgt: a = 123 Es gibt jedoch eine Ausnahme: \"s\" ist bereits von SuperCollider (SC) reserviert und verweist auf den aktuellen Server. Daher sollte \"s\" nicht \u00fcberschrieben werden. Lokale Namen Alternativ k\u00f6nnen wir vollst\u00e4ndige Namen verwenden. Es ist wichtig, dass diese mit Kleinbuchstaben beginnen. F\u00fcr diese Art von Namen m\u00fcssen sie mit \"var\" deklariert und in einem Code-Block stehen. Au\u00dferhalb der geschweiften Klammern haben diese Namen keine Bedeutung. Code-Bl\u00f6cke sind alle Teile, die sich zwischen zwei geschweiften Klammern befinden: ( var name = 123; name = name + 1; name ) Globale Namen Die letzte Art der Namenszuweisung erfolgt, indem wir vor den Namen eine Tilde setzen. Dadurch m\u00fcssen diese Namen nicht in einem Code-Block eingeschlossen sein und k\u00f6nnen \u00fcberall im Code verwendet werden. Beachten Sie, dass auch hier die Namen mit Kleinbuchstaben beginnen m\u00fcssen: ~drei = 3; ( ~vier = 4; ) ~sieben = ~drei + ~vier; Achtung: Wenn Sie mit Codebl\u00f6cken arbeiten, achten Sie darauf, dass das Ergebnis eines Codeblocks das ist, was in der letzten Zeile des Blocks steht!# Datenstrukturen Und nat\u00fcrlich k\u00f6nnen wir nicht nur Zahlen Namen geben, sondern jeder Art Datenstruktur. In Supercollider gibt es verschiedene Klassen, die ein Blueprint f\u00fcr die Daten repr\u00e4sentieren: Es gibt z.B. Zahlenklassen Integer und Float. Beispiele f\u00fcr diese Klassen sind 1 (Integer) oder 3.14 (Float). Die Klassen werden durch ihre Eigenschaften voneinander unterschieden. Wir k\u00f6nnen die Eigenschaften der Klassen in folgender Schreibweise abfragen: Klasse.Eigenschaft Achtung Wenn es sich bei der Eigenschaft um eine Funktion handelt, ist diese Schreibweise: Klasse.Funktion \u00e4quivalent zu: Funktion(Klasse) Mehr zu Funktionen sp\u00e4ter... Beispiel: Die Klasse Integer (und viele andere Objekte in SC) besitzt u.a. die Eigenschaft class , die angibt zu welcher Klasse eine Integer-Instanz geh\u00f6rt: 1.class Platzieren Sie den Cursor auf der Zeile und dr\u00fccken Sie die Tastenkombination Shift+Enter . Im Post-Window sehen Sie das Ergebnis -> Integer . Wir sagen, der Ausdruck 1.class evaluiert zu Integer . Auch der Quadratwurzel einer Zahl k\u00f6nnen wir durch die Eigenschaft sqrt (f\u00fcr square root) abfragen: 4.sqrt Achten Sie darauf, dass die sqrt -Eigenschaft nur f\u00fcr Zahlen gilt! Wir k\u00f6nnen z.B. diese Eigenschaft bei einem String (eine Zeichenkette eingeschlossen zwischen zwei Anf\u00fchrungszeichen) nicht abfragen, da diese Eigenschaft dort keinen Sinn ergibt. SuperCollider wird uns in dem Fall einen Fehler ausgeben: \"Musik Elektronik\".sqrt Die class -Eigenschaft hingegen kann sinnvollerweise auch auf Strings (und jedes andere Objekt) angewendet werden: \"Musik Elektronik\".class Hier sind einige Klassen (auf der Sprach-Ebene), mit denen wir sehr viel arbeiten werden: Integer ( 1 ) Float ( 3.14 ) String ( \"Musik Elektronik\" ) Array ( [1, 2, 3, 4] ) Boolean ( true ) \u00dcbung Schreiben Sie f\u00fcr jede der folgenden Aufgaben eine Zeile Code: Summe der Zahlen 2.4, 45, 0.234 Produkt der oben genannten Zahlen \u00dcbung Benutzen Sie die size -Eigenschaft, um herauszufinden, aus wie vielen Zeichen der folgende String besteht: \"1k2k3ja98d4nj281jkswe8s0dnmwer8c7q23ij18\" \u00dcbung Die size -Eigenschaft funktioniert auch f\u00fcr Arrays. Finden Sie die Anzahl der Objekte in dem folgenden Array heraus: [1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 3, 4, 5, 6, 5, 4, 3, 2] \u00dcbung Benutzen Sie die sum -Eigenschaft f\u00fcr Arrays, um die Summe aller Zahlen im obigen Array zu berechnen. Funktionen Wie bereits oben beschrieben, k\u00f6nnen wir eine Funktion in der folgenden Schreibweise aufrufen: Objekt.Funktion_des_Objekts oder Funktione_des_objekts(Objekt) Beispiele hierf\u00fcr sind: // Summe eines Arrays berechnen: [1, 2, 3, 4].sum; // \u00c4quivalent zu: sum([1, 2, 3, 4]); // Oder den Kehrwert einer Zahl: 4.reciprocal; // Gleichbedeutend mit: reciprocal(4); Aber manchmal ben\u00f6tigt eine Funktion mehr als eine Eingabe. Ein Beispiel ist das Berechnen einer Potenz, f\u00fcr das wir eine Basis und einen Exponenten ben\u00f6tigen. In SuperCollider l\u00e4sst sich \"zwei hoch drei\" sowohl mit der Punkt-Schreibweise ausdr\u00fccken: 2.pow(3) als auch in Funktions-Schreibweise: pow(2, 3) Ein weiteres Beispiel ist die Funktion linlin , bei der eine Zahl aus einem linearen Zahlenraum auf einen anderen linearen Zahlenraum abgebildet wird. In unserem Beispiel wird die Zahl 0.5 aus dem Bereich von 0 bis 1 auf den Bereich von 10 bis 20 abgebildet, wobei dies der Zahl 15 entspricht. 0.5.linlin(0, 1, 10, 20) Hinweis Viele Klassen in SuperCollider verf\u00fcgen \u00fcber sogenannte Klassenmethoden. Diese Funktionen werden auf die Klasse selbst angewendet und nicht, wie in unseren bisherigen Beispielen, auf eine Instanz der Klasse. Zum Beispiel besitzt die Klasse Array die Klassenmethode geom , mit der eine geometrische Reihe erzeugt werden kann. Der Aufruf einer Klassenmethode erfolgt wie folgt: Array.geom(10, 1, 2) Dies erzeugt ein Array mit 10 Elementen, wobei das erste Element 1 ist und jedes weitere Element die Verdopplung des vorherigen Elements darstellt: [ 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 ] (siehe auch: Geometrische Reihe ). F\u00fcr weitere Beispiele der Klassenmethoden der Array-Klasse werfen Sie einen Blick auf die Dokumentationsseite Array/Class Methods . Wir k\u00f6nnen auch unsere eigenen Funktionen definieren. Unten habe ich alle Zeilen innerhalb eines Code-Blocks (runden Klammern) platziert, um sie alle zusammen evaluieren zu k\u00f6nnen. Ich verwende auch einen globalen Namen (mit einer Tilde), da ich von \u00fcberall auf meine Funktion zugreifen m\u00f6chte. Die Funktion erh\u00e4lt zwei Zahlen als Argumente und evaluiert zu ihrer Summe der Quadratzahlen. Ich definiere hier meine Funktion und gebe ihr den Namen \"quadsum\". Der Funktionsk\u00f6rper wird zwischen geschweiften Klammern definiert. Der Wert, zu dem die Funktion ausgewertet wird, ist der letzte Ausdruck im Funktionsk\u00f6rper. ( ~quadsum = {} ) Hier definiere ich zuerst, wie viele Eingaben meine Funktion akzeptieren soll, und gebe ihnen eindeutige Namen: ( ~quadsum = { arg num1, num2; } ) Ab hier beginnt die eigentliche Funktionsdefinition. Zuerst speichere ich die Quadrate der beiden Argumente \"num1\" und \"num2\" in internen Variablen. Zur Berechnung der Quadrate der Zahlen verwende ich die eingebaute Funktion \"squared\". ( ~quadsum = { arg num1, num2; var quad1 = num1.squared; var quad2 = num2.squared; } ) Und der letzte Ausdruck ist der eigentliche Wert, den die Funktion zur\u00fcckgibt: ( ~quadsum = { arg num1, num2; var quad1 = num1.squared; var quad2 = num2.squared; quad1 + quad2; } ) Jetzt, mit dem Cursor innerhalb des Blocks (zwischen den beiden runden Klammern), dr\u00fccken Sie die Tastenkombination Ctrl+Enter . Der Block (und der darin enthaltene Code) wird ausgewertet, und wir sehen im Post-Window \"-> a Function\". Jetzt k\u00f6nnen wir unsere Funktion aufrufen: ~quadsum.(2, 3); // -> 13 ~quadsum.(4, 5); // -> 41 Bitte beachten Sie, dass f\u00fcr selbstdefinierte Funktionen die Schreibweise mit dem Punkt nicht existiert. Um unsere eigene Funktion aufzurufen, verwenden wir die folgende Syntax: Funktion.(arg1, arg2, ...) Falls unsere Funktion keine Argumente bekommt, bleibt die Klammer nat\u00fcrlich leer! ( // Zuf\u00e4llige Zahl zwischen 1 und 10 ~rand_1_to_10 = { 1.rrand(10) } ) // Aufruf wie folgt: ~rand_1_to_10.() \u00dcbung Schreiben Sie eine Funktion, die zwei Argumente erh\u00e4lt. Das erste Argument ist ein Array, das eine beliebige Anzahl von Zahlen enth\u00e4lt, und das zweite Argument ist die Index-Nummer eines der Elemente in diesem Array. Das Ergebnis der Funktion sollte ein neues Array sein, in dem jedes Element des Eingabe-Arrays mit der Zahl an der Index-Nummer skaliert ist. Tipp 1: Sie k\u00f6nnen ein Array von Zahlen skalieren, indem Sie das gesamte Array mit einer Zahl multiplizieren. Zum Beispiel: [1, 2, 3, 4] * 10 // -> [10, 20, 30, 40] Tipp 2: Um ein Element an einer bestimmten Index-Nummer aus einem Array zu nehmen, verwenden Sie die at -Methode f\u00fcr Arrays. Diese Methode wird wie folgt aufgerufen (Beachten Sie, dass Index-Nummern 0-basiert sind): [1, 2, 3, 4].at(2) // -> 3 \u00dcbung: Mittlere Zahl finden Schreiben Sie eine Funktion, die drei Zahlen als Argumente erh\u00e4lt und die mittlere Zahl zur\u00fcckgibt. Nennen Sie die Funktion ~findMiddle . Tipp 1: Die sort Methode eines Arrays sortiert das Array in-place . Tipp 2: Die at Methode erlaubt das Abrufen eines Elements an einer bestimmten Indexposition in einem Array. \u00dcbung: Berechne den Durchschnitt Schreiben Sie eine Funktion namens ~average , die eine Liste von Zahlen als Argument erh\u00e4lt und den Durchschnitt dieser Zahlen berechnet und zur\u00fcckgibt. Tipp: Folgende Methoden k\u00f6nnen hilfreich sein: size und sum . \u00dcbung: Umdrehen einer Zeichenkette Schreiben Sie eine Funktion ~reverseString , die eine Zeichenkette als Argument erh\u00e4lt und die umgekehrte Zeichenkette zur\u00fcckgibt. Tipp: Dr\u00fccken Sie die Tastenkombination Shift+Ctrl+D, um die Dokumentationsseite zu durchsuchen. Suchen Sie nach \"reverse\". Dort werden alle Klassen aufgelistet, die diese Funktion/Eigenschaft implementieren. Klicken Sie auf den Eintrag \"ArrayedCollection\". Sie k\u00f6nnen die Methode reverse in Ihrer Funktion verwenden. \u00dcbung: Fl\u00e4cheninhalt eines Rechtecks berechnen Schreiben Sie eine Funktion ~calculateRectangleArea , die die L\u00e4nge und Breite eines Rechtecks als Argumente erh\u00e4lt und den Fl\u00e4cheninhalt des Rechtecks zur\u00fcckgibt. \u00dcbung: Volumen einer Kugel berechnen Schreiben Sie eine Funktion ~calculateSphereVolume , die den Radius einer Kugel als Argument erh\u00e4lt und das Volumen der Kugel berechnet und zur\u00fcckgibt. Tipp 1: Die Formel zur Berechnung des Volumens einer Kugel lautet: V = 4/3 x \u03c0 x r^3 Tipp 2: Die Zahl Pi k\u00f6nnen Sie einfach als pi schreiben. \u00dcbung: Tonleiter generieren Definieren Sie zwei globale Variablen ~majorPattern und ~minorPattern . Definieren Sie eine Funktion ~generateScale , die drei Argumente erh\u00e4lt: eine MIDI-Keynummer, ein Skalenmuster und eine Oktavnummer. Die Funktion soll die gew\u00fcnschte Tonleiter (angegeben als scalePattern , entweder ~majorPattern oder ~minorPattern ) generieren, beginnend bei der MIDI-Keynummer und transponiert um die angegebene Anzahl von Oktaven nach oben oder nach unten. Iterieren mit do und collect In SuperCollider ist das Iterieren \u00fcber Listen und Arrays und das Sammeln von Ergebnissen eine wichtige Technik, um komplexe Operationen auf Daten auszuf\u00fchren. Die Methoden do und collect sind dabei sehr hilfreich. Das do -Muster Die Methode do wird verwendet, um \u00fcber die Elemente einer Liste oder Array zu iterieren und eine Aktion auf jedes Element auszuf\u00fchren. Zum Beispiel: // Iteriert \u00fcber die Array und zeigt jedes Element im Post-Window [1, 2, 3, 4, 5].do { arg element; element.postln; } Dieser Code gibt nacheinander die Zahlen 1 bis 5 aus. Das collect -Muster Die Methode collect wird verwendet, um eine neue Liste/Array zu erstellen, indem eine Aktion auf jedes Element der urspr\u00fcnglichen Liste angewendet wird. Zum Beispiel: // Erstellt eine neue Array/Liste, in der jedes Element um 10 erh\u00f6ht ist var originalList = [1, 2, 3, 4, 5]; var newList = originalList.collect { arg element; element + 10; }; newList.postln; // -> [ 11, 12, 13, 14, 15 ] Beachten Sie, dass collect eine neue Liste erstellt, und Sie k\u00f6nnen sie einer Variablen zuweisen, um das Ergebnis zu speichern. Sie k\u00f6nnen viele andere Operationen mit do und collect durchf\u00fchren, z. B. Filtern von Elementen, Berechnen von Durchschnittswerten, Suchen nach bestimmten Werten usw. \u00dcbung: Quadratzahlen erzeugen Schreiben Sie eine Funktion namens ~squareNumbers , die eine Liste von Zahlen als Argument erh\u00e4lt und eine Liste zur\u00fcckgibt, in der die Quadrate der urspr\u00fcnglichen Zahlen stehen. Benutzen sie collect . \u00dcbung: Fibonacci-Folge generieren Schreiben Sie eine Funktion ~generateFibonacci , die eine positive Ganzzahl n als Argument erh\u00e4lt und die ersten n Zahlen in der Fibonacci-Folge zur\u00fcckgibt. Kontrollstrukturen Manchmal m\u00f6chten wir Teile unseres Codes nur ausf\u00fchren, wenn eine bestimmte Bedingung erf\u00fcllt ist. Das erreichen wir mithilfe der sogenannten Kontrollstrukturen . if Eines dieser Mittel ist das if -Statement, das die folgende Form hat: ( if (Bedingung ist erf\u00fcllt), {Dann evaluiere diese Funktion}, {Ansonsten evaluiere diese Funktion} ) Wir schauen uns ein Beispiel an: Wir testen den Wert einer Zufallszahl und m\u00f6chten eine Zeile im Post-Fenster ausgeben lassen. Diese Zeile soll die Nachricht \"Gr\u00f6\u00dfer als Zehn\" ausgeben, wenn unsere Zahl gr\u00f6\u00dfer als 10 ist, und \"Kleiner als Zehn\" ausgeben, wenn die Zahl kleiner als 10 ist. ( // Eine Zufallszahl generieren var zahl = 0.rrand(20); if ( // Den Wert der Zufallszahl auswerten (zahl > 10), // Wenn die Zahl gr\u00f6\u00dfer ist als 10, dann rufen wir diese Funktion auf {zahl.postln; \"Die Zahl ist gr\u00f6\u00dfer als 10\"}, // Ansonsten rufen wir diese Funktion auf {zahl.postln; \"Die Zahl ist kleiner als 10\"} ) ) \u00dcbung: Schreiben Sie eine Funktion namens randomColor , die 50% der Zeit den String \"Rot\" und 50% der Zeit den String \"Gelb\" ausgibt. Tipp: Nutzen Sie die eingebaute Funktion coin . Diese Funktion erh\u00e4lt eine Zahl zwischen 0 und 1 als Argument und gibt mit der angegebenen Wahrscheinlichkeit die booleschen Werte true oder false aus. Zum Beispiel wird 1.coin immer true ausgeben, w\u00e4hrend 0.coin immer zu false evaluiert wird. \u00dcbung: \u00dcberpr\u00fcfung der Geradheit einer Zahl Schreiben Sie eine Funktion, die \u00fcberpr\u00fcft, ob eine gegebene Zahl gerade oder ungerade ist, und eine entsprechende Nachricht ausgibt. Tipp: Die mod -Funktion kann n\u00fctzlich sein. Lesen Sie daf\u00fcr die entsprechende Dokumentationsseite. \u00dcbung: Palindrom-\u00dcberpr\u00fcfung Schreiben Sie eine Funktion, die \u00fcberpr\u00fcft, ob ein gegebener String ein Palindrom ist, d.h., ob er von vorne und von hinten gleich gelesen wird. \u00dcbung: Schachbrett-Muster Schreiben Sie eine Funktion, die ein Schachbrett-Muster mit den Zeichen \"#\" und \" \" erstellt. Die Gr\u00f6\u00dfe des Schachbretts soll als Argument \u00fcbergeben werden. Tipp: Mit folgendem Ausdruck erhalten Sie ein zweidimensionales Array, dessen Unter-Arrays mit Zahlen zwischen 0 und 7 (einschlie\u00dflich) gef\u00fcllt sind und sich rotierend von der n\u00e4chsten Zahl fortsetzen: Array.fill(8, {arg x; Array.iota(8).rotate(x * -1)}) Zur Veranschaulichung evaluieren Sie den folgenden Block, der dieses zweidimensionale Array im Post-Window ausgibt: ( Array.fill(8, {arg x; Array.iota(8).rotate(x * -1)}).do { arg row; row.do { arg col; \"% \".postf(col) }; \"\".postln } ) // Ergebnis im Post-Window: 0 1 2 3 4 5 6 7 1 2 3 4 5 6 7 0 2 3 4 5 6 7 0 1 3 4 5 6 7 0 1 2 4 5 6 7 0 1 2 3 5 6 7 0 1 2 3 4 6 7 0 1 2 3 4 5 7 0 1 2 3 4 5 6 case Wenn wir mehr als eine Bedingung testen m\u00f6chten, um in jeder Situation anders vorzugehen, k\u00f6nnen wir die case -Konstruktion nutzen. Sie hat die folgende Form: ( case // Kondition und Funktion 1 {Kondition 1 ist erf\u00fcllt} {evaluiere die Funktion 1} // Kondition und Funktion 2 {Kondition 2 ist erf\u00fcllt} {evaluiere die Funktion 2} // Kondition und Funktion 3 {Kondition 3 ist erf\u00fcllt} {evaluiere die Funktion 3} // Diese Zeile wird nur evaluiert, wenn keine der Bedingungen oben erf\u00fcllt sind {true} {sonst evaluiere diese Funktion} ) Ein Beispiel: ( // Testen, ob eine Zufallszahl zwischen 10 und 100 durch 7, 5 oder 3 teilbar ist var n = rrand(10, 100); case { n.mod(7) == 0 } { \"% ist durch 7 teilbar\".postf(n) } { n.mod(5) == 0 } { \"% ist durch 5 teilbar\".postf(n) } { n.mod(3) == 0 } { \"% ist durch 3 teilbar\".postf(n) } { true } { \"% ist durch 7, 5 und 3 nicht teilbar\".postf(n) } ) \u00dcbung: Tonart-Erkennung Schreiben Sie mithilfe von case eine Funktion, die als Argument eine Sequenz von MIDI-Notennummern erh\u00e4lt. Das Programm soll diese Sequenz intervalle analysieren. Wenn diese Sequenz einer Dur- oder Moll-Tonleiter ( nat\u00fcrliches , harmonisches oder melodisches Moll, alle in aufsteigender Form) entspricht, soll die Funktion den Namen der Tonleiter als einen String zur\u00fcckgeben. Andernfalls soll der String \"Keine erkennbare Tonleiter\" zur\u00fcckgegeben werden. Tipp: Folgende Definitionen k\u00f6nnen Ihnen bei der Aufgabe n\u00fctzlich sein: ( // Die Intervallmuster der Dur-Tonleiter und drei Varianten der Moll-Tonleiter ~majorIntervals = [ 2, 2, 1, 2, 2, 2, 1 ]; ~nat_minorIntervals = [ 2, 1, 2, 2, 1, 2, 2 ]; ~harm_minorIntervals = [ 2, 1, 2, 2, 1, 3, 1 ]; ~mel_minorIntervals = [ 2, 1, 2, 2, 2, 2, 1 ]; // Bekommt ein Array von Zahlen (arg nums) und gibt ein Array von // Intervallen zwischen zwei benachbarten Zahlen aus ~getIntervals = { arg nums; var intervals = Array.new(nums.size - 1); nums.doAdjacentPairs({arg a, b; intervals.add(b - a)}); intervals } ) Tipp: Die Funktion midiname erh\u00e4lt eine Zahl und gibt den Namen der MIDI-Nummer als einen String aus. Tipp: String-Konkatenation k\u00f6nnen wir mit dem ++ -Operator erreichen: \"Super\" ++ \"Collider\" // -> \"SuperCollider\" F\u00fcr weitere Informationen zu Kontrollstrukturen suchen Sie in der Dokumentation nach \"Control Structures\" ( Ctrl+Shift+D und nach dem Begriff suchen).","title":"Sprache"},{"location":"lang/#einfuhrung-in-die-sprache-supercollider","text":"","title":"Einf\u00fchrung in die Sprache SuperCollider"},{"location":"lang/#namengebung","text":"In der Programmierung (f\u00fcr uns Menschen) ist es allgemein einfacher, sich Namen anstelle von komplexen Daten zu merken. Daher k\u00f6nnen wir in unserem Code Namen f\u00fcr unsere Daten zuweisen. Es gibt drei M\u00f6glichkeiten Namen zu definieren:","title":"Namengebung"},{"location":"lang/#einzellige-namen","text":"Hierf\u00fcr verwenden wir einzelne Kleinbuchstaben, wie folgt: a = 123 Es gibt jedoch eine Ausnahme: \"s\" ist bereits von SuperCollider (SC) reserviert und verweist auf den aktuellen Server. Daher sollte \"s\" nicht \u00fcberschrieben werden.","title":"Einzellige Namen"},{"location":"lang/#lokale-namen","text":"Alternativ k\u00f6nnen wir vollst\u00e4ndige Namen verwenden. Es ist wichtig, dass diese mit Kleinbuchstaben beginnen. F\u00fcr diese Art von Namen m\u00fcssen sie mit \"var\" deklariert und in einem Code-Block stehen. Au\u00dferhalb der geschweiften Klammern haben diese Namen keine Bedeutung. Code-Bl\u00f6cke sind alle Teile, die sich zwischen zwei geschweiften Klammern befinden: ( var name = 123; name = name + 1; name )","title":"Lokale Namen"},{"location":"lang/#globale-namen","text":"Die letzte Art der Namenszuweisung erfolgt, indem wir vor den Namen eine Tilde setzen. Dadurch m\u00fcssen diese Namen nicht in einem Code-Block eingeschlossen sein und k\u00f6nnen \u00fcberall im Code verwendet werden. Beachten Sie, dass auch hier die Namen mit Kleinbuchstaben beginnen m\u00fcssen: ~drei = 3; ( ~vier = 4; ) ~sieben = ~drei + ~vier; Achtung: Wenn Sie mit Codebl\u00f6cken arbeiten, achten Sie darauf, dass das Ergebnis eines Codeblocks das ist, was in der letzten Zeile des Blocks steht!# Datenstrukturen Und nat\u00fcrlich k\u00f6nnen wir nicht nur Zahlen Namen geben, sondern jeder Art Datenstruktur. In Supercollider gibt es verschiedene Klassen, die ein Blueprint f\u00fcr die Daten repr\u00e4sentieren: Es gibt z.B. Zahlenklassen Integer und Float. Beispiele f\u00fcr diese Klassen sind 1 (Integer) oder 3.14 (Float). Die Klassen werden durch ihre Eigenschaften voneinander unterschieden. Wir k\u00f6nnen die Eigenschaften der Klassen in folgender Schreibweise abfragen: Klasse.Eigenschaft Achtung Wenn es sich bei der Eigenschaft um eine Funktion handelt, ist diese Schreibweise: Klasse.Funktion \u00e4quivalent zu: Funktion(Klasse) Mehr zu Funktionen sp\u00e4ter... Beispiel: Die Klasse Integer (und viele andere Objekte in SC) besitzt u.a. die Eigenschaft class , die angibt zu welcher Klasse eine Integer-Instanz geh\u00f6rt: 1.class Platzieren Sie den Cursor auf der Zeile und dr\u00fccken Sie die Tastenkombination Shift+Enter . Im Post-Window sehen Sie das Ergebnis -> Integer . Wir sagen, der Ausdruck 1.class evaluiert zu Integer . Auch der Quadratwurzel einer Zahl k\u00f6nnen wir durch die Eigenschaft sqrt (f\u00fcr square root) abfragen: 4.sqrt Achten Sie darauf, dass die sqrt -Eigenschaft nur f\u00fcr Zahlen gilt! Wir k\u00f6nnen z.B. diese Eigenschaft bei einem String (eine Zeichenkette eingeschlossen zwischen zwei Anf\u00fchrungszeichen) nicht abfragen, da diese Eigenschaft dort keinen Sinn ergibt. SuperCollider wird uns in dem Fall einen Fehler ausgeben: \"Musik Elektronik\".sqrt Die class -Eigenschaft hingegen kann sinnvollerweise auch auf Strings (und jedes andere Objekt) angewendet werden: \"Musik Elektronik\".class Hier sind einige Klassen (auf der Sprach-Ebene), mit denen wir sehr viel arbeiten werden: Integer ( 1 ) Float ( 3.14 ) String ( \"Musik Elektronik\" ) Array ( [1, 2, 3, 4] ) Boolean ( true ) \u00dcbung Schreiben Sie f\u00fcr jede der folgenden Aufgaben eine Zeile Code: Summe der Zahlen 2.4, 45, 0.234 Produkt der oben genannten Zahlen \u00dcbung Benutzen Sie die size -Eigenschaft, um herauszufinden, aus wie vielen Zeichen der folgende String besteht: \"1k2k3ja98d4nj281jkswe8s0dnmwer8c7q23ij18\" \u00dcbung Die size -Eigenschaft funktioniert auch f\u00fcr Arrays. Finden Sie die Anzahl der Objekte in dem folgenden Array heraus: [1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 3, 4, 5, 6, 5, 4, 3, 2] \u00dcbung Benutzen Sie die sum -Eigenschaft f\u00fcr Arrays, um die Summe aller Zahlen im obigen Array zu berechnen.","title":"Globale Namen"},{"location":"lang/#funktionen","text":"Wie bereits oben beschrieben, k\u00f6nnen wir eine Funktion in der folgenden Schreibweise aufrufen: Objekt.Funktion_des_Objekts oder Funktione_des_objekts(Objekt) Beispiele hierf\u00fcr sind: // Summe eines Arrays berechnen: [1, 2, 3, 4].sum; // \u00c4quivalent zu: sum([1, 2, 3, 4]); // Oder den Kehrwert einer Zahl: 4.reciprocal; // Gleichbedeutend mit: reciprocal(4); Aber manchmal ben\u00f6tigt eine Funktion mehr als eine Eingabe. Ein Beispiel ist das Berechnen einer Potenz, f\u00fcr das wir eine Basis und einen Exponenten ben\u00f6tigen. In SuperCollider l\u00e4sst sich \"zwei hoch drei\" sowohl mit der Punkt-Schreibweise ausdr\u00fccken: 2.pow(3) als auch in Funktions-Schreibweise: pow(2, 3) Ein weiteres Beispiel ist die Funktion linlin , bei der eine Zahl aus einem linearen Zahlenraum auf einen anderen linearen Zahlenraum abgebildet wird. In unserem Beispiel wird die Zahl 0.5 aus dem Bereich von 0 bis 1 auf den Bereich von 10 bis 20 abgebildet, wobei dies der Zahl 15 entspricht. 0.5.linlin(0, 1, 10, 20) Hinweis Viele Klassen in SuperCollider verf\u00fcgen \u00fcber sogenannte Klassenmethoden. Diese Funktionen werden auf die Klasse selbst angewendet und nicht, wie in unseren bisherigen Beispielen, auf eine Instanz der Klasse. Zum Beispiel besitzt die Klasse Array die Klassenmethode geom , mit der eine geometrische Reihe erzeugt werden kann. Der Aufruf einer Klassenmethode erfolgt wie folgt: Array.geom(10, 1, 2) Dies erzeugt ein Array mit 10 Elementen, wobei das erste Element 1 ist und jedes weitere Element die Verdopplung des vorherigen Elements darstellt: [ 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 ] (siehe auch: Geometrische Reihe ). F\u00fcr weitere Beispiele der Klassenmethoden der Array-Klasse werfen Sie einen Blick auf die Dokumentationsseite Array/Class Methods . Wir k\u00f6nnen auch unsere eigenen Funktionen definieren. Unten habe ich alle Zeilen innerhalb eines Code-Blocks (runden Klammern) platziert, um sie alle zusammen evaluieren zu k\u00f6nnen. Ich verwende auch einen globalen Namen (mit einer Tilde), da ich von \u00fcberall auf meine Funktion zugreifen m\u00f6chte. Die Funktion erh\u00e4lt zwei Zahlen als Argumente und evaluiert zu ihrer Summe der Quadratzahlen. Ich definiere hier meine Funktion und gebe ihr den Namen \"quadsum\". Der Funktionsk\u00f6rper wird zwischen geschweiften Klammern definiert. Der Wert, zu dem die Funktion ausgewertet wird, ist der letzte Ausdruck im Funktionsk\u00f6rper. ( ~quadsum = {} ) Hier definiere ich zuerst, wie viele Eingaben meine Funktion akzeptieren soll, und gebe ihnen eindeutige Namen: ( ~quadsum = { arg num1, num2; } ) Ab hier beginnt die eigentliche Funktionsdefinition. Zuerst speichere ich die Quadrate der beiden Argumente \"num1\" und \"num2\" in internen Variablen. Zur Berechnung der Quadrate der Zahlen verwende ich die eingebaute Funktion \"squared\". ( ~quadsum = { arg num1, num2; var quad1 = num1.squared; var quad2 = num2.squared; } ) Und der letzte Ausdruck ist der eigentliche Wert, den die Funktion zur\u00fcckgibt: ( ~quadsum = { arg num1, num2; var quad1 = num1.squared; var quad2 = num2.squared; quad1 + quad2; } ) Jetzt, mit dem Cursor innerhalb des Blocks (zwischen den beiden runden Klammern), dr\u00fccken Sie die Tastenkombination Ctrl+Enter . Der Block (und der darin enthaltene Code) wird ausgewertet, und wir sehen im Post-Window \"-> a Function\". Jetzt k\u00f6nnen wir unsere Funktion aufrufen: ~quadsum.(2, 3); // -> 13 ~quadsum.(4, 5); // -> 41 Bitte beachten Sie, dass f\u00fcr selbstdefinierte Funktionen die Schreibweise mit dem Punkt nicht existiert. Um unsere eigene Funktion aufzurufen, verwenden wir die folgende Syntax: Funktion.(arg1, arg2, ...) Falls unsere Funktion keine Argumente bekommt, bleibt die Klammer nat\u00fcrlich leer! ( // Zuf\u00e4llige Zahl zwischen 1 und 10 ~rand_1_to_10 = { 1.rrand(10) } ) // Aufruf wie folgt: ~rand_1_to_10.() \u00dcbung Schreiben Sie eine Funktion, die zwei Argumente erh\u00e4lt. Das erste Argument ist ein Array, das eine beliebige Anzahl von Zahlen enth\u00e4lt, und das zweite Argument ist die Index-Nummer eines der Elemente in diesem Array. Das Ergebnis der Funktion sollte ein neues Array sein, in dem jedes Element des Eingabe-Arrays mit der Zahl an der Index-Nummer skaliert ist. Tipp 1: Sie k\u00f6nnen ein Array von Zahlen skalieren, indem Sie das gesamte Array mit einer Zahl multiplizieren. Zum Beispiel: [1, 2, 3, 4] * 10 // -> [10, 20, 30, 40] Tipp 2: Um ein Element an einer bestimmten Index-Nummer aus einem Array zu nehmen, verwenden Sie die at -Methode f\u00fcr Arrays. Diese Methode wird wie folgt aufgerufen (Beachten Sie, dass Index-Nummern 0-basiert sind): [1, 2, 3, 4].at(2) // -> 3 \u00dcbung: Mittlere Zahl finden Schreiben Sie eine Funktion, die drei Zahlen als Argumente erh\u00e4lt und die mittlere Zahl zur\u00fcckgibt. Nennen Sie die Funktion ~findMiddle . Tipp 1: Die sort Methode eines Arrays sortiert das Array in-place . Tipp 2: Die at Methode erlaubt das Abrufen eines Elements an einer bestimmten Indexposition in einem Array. \u00dcbung: Berechne den Durchschnitt Schreiben Sie eine Funktion namens ~average , die eine Liste von Zahlen als Argument erh\u00e4lt und den Durchschnitt dieser Zahlen berechnet und zur\u00fcckgibt. Tipp: Folgende Methoden k\u00f6nnen hilfreich sein: size und sum . \u00dcbung: Umdrehen einer Zeichenkette Schreiben Sie eine Funktion ~reverseString , die eine Zeichenkette als Argument erh\u00e4lt und die umgekehrte Zeichenkette zur\u00fcckgibt. Tipp: Dr\u00fccken Sie die Tastenkombination Shift+Ctrl+D, um die Dokumentationsseite zu durchsuchen. Suchen Sie nach \"reverse\". Dort werden alle Klassen aufgelistet, die diese Funktion/Eigenschaft implementieren. Klicken Sie auf den Eintrag \"ArrayedCollection\". Sie k\u00f6nnen die Methode reverse in Ihrer Funktion verwenden. \u00dcbung: Fl\u00e4cheninhalt eines Rechtecks berechnen Schreiben Sie eine Funktion ~calculateRectangleArea , die die L\u00e4nge und Breite eines Rechtecks als Argumente erh\u00e4lt und den Fl\u00e4cheninhalt des Rechtecks zur\u00fcckgibt. \u00dcbung: Volumen einer Kugel berechnen Schreiben Sie eine Funktion ~calculateSphereVolume , die den Radius einer Kugel als Argument erh\u00e4lt und das Volumen der Kugel berechnet und zur\u00fcckgibt. Tipp 1: Die Formel zur Berechnung des Volumens einer Kugel lautet: V = 4/3 x \u03c0 x r^3 Tipp 2: Die Zahl Pi k\u00f6nnen Sie einfach als pi schreiben. \u00dcbung: Tonleiter generieren Definieren Sie zwei globale Variablen ~majorPattern und ~minorPattern . Definieren Sie eine Funktion ~generateScale , die drei Argumente erh\u00e4lt: eine MIDI-Keynummer, ein Skalenmuster und eine Oktavnummer. Die Funktion soll die gew\u00fcnschte Tonleiter (angegeben als scalePattern , entweder ~majorPattern oder ~minorPattern ) generieren, beginnend bei der MIDI-Keynummer und transponiert um die angegebene Anzahl von Oktaven nach oben oder nach unten.","title":"Funktionen"},{"location":"lang/#iterieren-mit-do-und-collect","text":"In SuperCollider ist das Iterieren \u00fcber Listen und Arrays und das Sammeln von Ergebnissen eine wichtige Technik, um komplexe Operationen auf Daten auszuf\u00fchren. Die Methoden do und collect sind dabei sehr hilfreich.","title":"Iterieren mit do und collect"},{"location":"lang/#das-do-muster","text":"Die Methode do wird verwendet, um \u00fcber die Elemente einer Liste oder Array zu iterieren und eine Aktion auf jedes Element auszuf\u00fchren. Zum Beispiel: // Iteriert \u00fcber die Array und zeigt jedes Element im Post-Window [1, 2, 3, 4, 5].do { arg element; element.postln; } Dieser Code gibt nacheinander die Zahlen 1 bis 5 aus.","title":"Das do-Muster"},{"location":"lang/#das-collect-muster","text":"Die Methode collect wird verwendet, um eine neue Liste/Array zu erstellen, indem eine Aktion auf jedes Element der urspr\u00fcnglichen Liste angewendet wird. Zum Beispiel: // Erstellt eine neue Array/Liste, in der jedes Element um 10 erh\u00f6ht ist var originalList = [1, 2, 3, 4, 5]; var newList = originalList.collect { arg element; element + 10; }; newList.postln; // -> [ 11, 12, 13, 14, 15 ] Beachten Sie, dass collect eine neue Liste erstellt, und Sie k\u00f6nnen sie einer Variablen zuweisen, um das Ergebnis zu speichern. Sie k\u00f6nnen viele andere Operationen mit do und collect durchf\u00fchren, z. B. Filtern von Elementen, Berechnen von Durchschnittswerten, Suchen nach bestimmten Werten usw. \u00dcbung: Quadratzahlen erzeugen Schreiben Sie eine Funktion namens ~squareNumbers , die eine Liste von Zahlen als Argument erh\u00e4lt und eine Liste zur\u00fcckgibt, in der die Quadrate der urspr\u00fcnglichen Zahlen stehen. Benutzen sie collect . \u00dcbung: Fibonacci-Folge generieren Schreiben Sie eine Funktion ~generateFibonacci , die eine positive Ganzzahl n als Argument erh\u00e4lt und die ersten n Zahlen in der Fibonacci-Folge zur\u00fcckgibt.","title":"Das collect-Muster"},{"location":"lang/#kontrollstrukturen","text":"Manchmal m\u00f6chten wir Teile unseres Codes nur ausf\u00fchren, wenn eine bestimmte Bedingung erf\u00fcllt ist. Das erreichen wir mithilfe der sogenannten Kontrollstrukturen .","title":"Kontrollstrukturen"},{"location":"lang/#if","text":"Eines dieser Mittel ist das if -Statement, das die folgende Form hat: ( if (Bedingung ist erf\u00fcllt), {Dann evaluiere diese Funktion}, {Ansonsten evaluiere diese Funktion} ) Wir schauen uns ein Beispiel an: Wir testen den Wert einer Zufallszahl und m\u00f6chten eine Zeile im Post-Fenster ausgeben lassen. Diese Zeile soll die Nachricht \"Gr\u00f6\u00dfer als Zehn\" ausgeben, wenn unsere Zahl gr\u00f6\u00dfer als 10 ist, und \"Kleiner als Zehn\" ausgeben, wenn die Zahl kleiner als 10 ist. ( // Eine Zufallszahl generieren var zahl = 0.rrand(20); if ( // Den Wert der Zufallszahl auswerten (zahl > 10), // Wenn die Zahl gr\u00f6\u00dfer ist als 10, dann rufen wir diese Funktion auf {zahl.postln; \"Die Zahl ist gr\u00f6\u00dfer als 10\"}, // Ansonsten rufen wir diese Funktion auf {zahl.postln; \"Die Zahl ist kleiner als 10\"} ) ) \u00dcbung: Schreiben Sie eine Funktion namens randomColor , die 50% der Zeit den String \"Rot\" und 50% der Zeit den String \"Gelb\" ausgibt. Tipp: Nutzen Sie die eingebaute Funktion coin . Diese Funktion erh\u00e4lt eine Zahl zwischen 0 und 1 als Argument und gibt mit der angegebenen Wahrscheinlichkeit die booleschen Werte true oder false aus. Zum Beispiel wird 1.coin immer true ausgeben, w\u00e4hrend 0.coin immer zu false evaluiert wird. \u00dcbung: \u00dcberpr\u00fcfung der Geradheit einer Zahl Schreiben Sie eine Funktion, die \u00fcberpr\u00fcft, ob eine gegebene Zahl gerade oder ungerade ist, und eine entsprechende Nachricht ausgibt. Tipp: Die mod -Funktion kann n\u00fctzlich sein. Lesen Sie daf\u00fcr die entsprechende Dokumentationsseite. \u00dcbung: Palindrom-\u00dcberpr\u00fcfung Schreiben Sie eine Funktion, die \u00fcberpr\u00fcft, ob ein gegebener String ein Palindrom ist, d.h., ob er von vorne und von hinten gleich gelesen wird. \u00dcbung: Schachbrett-Muster Schreiben Sie eine Funktion, die ein Schachbrett-Muster mit den Zeichen \"#\" und \" \" erstellt. Die Gr\u00f6\u00dfe des Schachbretts soll als Argument \u00fcbergeben werden. Tipp: Mit folgendem Ausdruck erhalten Sie ein zweidimensionales Array, dessen Unter-Arrays mit Zahlen zwischen 0 und 7 (einschlie\u00dflich) gef\u00fcllt sind und sich rotierend von der n\u00e4chsten Zahl fortsetzen: Array.fill(8, {arg x; Array.iota(8).rotate(x * -1)}) Zur Veranschaulichung evaluieren Sie den folgenden Block, der dieses zweidimensionale Array im Post-Window ausgibt: ( Array.fill(8, {arg x; Array.iota(8).rotate(x * -1)}).do { arg row; row.do { arg col; \"% \".postf(col) }; \"\".postln } ) // Ergebnis im Post-Window: 0 1 2 3 4 5 6 7 1 2 3 4 5 6 7 0 2 3 4 5 6 7 0 1 3 4 5 6 7 0 1 2 4 5 6 7 0 1 2 3 5 6 7 0 1 2 3 4 6 7 0 1 2 3 4 5 7 0 1 2 3 4 5 6","title":"if"},{"location":"lang/#case","text":"Wenn wir mehr als eine Bedingung testen m\u00f6chten, um in jeder Situation anders vorzugehen, k\u00f6nnen wir die case -Konstruktion nutzen. Sie hat die folgende Form: ( case // Kondition und Funktion 1 {Kondition 1 ist erf\u00fcllt} {evaluiere die Funktion 1} // Kondition und Funktion 2 {Kondition 2 ist erf\u00fcllt} {evaluiere die Funktion 2} // Kondition und Funktion 3 {Kondition 3 ist erf\u00fcllt} {evaluiere die Funktion 3} // Diese Zeile wird nur evaluiert, wenn keine der Bedingungen oben erf\u00fcllt sind {true} {sonst evaluiere diese Funktion} ) Ein Beispiel: ( // Testen, ob eine Zufallszahl zwischen 10 und 100 durch 7, 5 oder 3 teilbar ist var n = rrand(10, 100); case { n.mod(7) == 0 } { \"% ist durch 7 teilbar\".postf(n) } { n.mod(5) == 0 } { \"% ist durch 5 teilbar\".postf(n) } { n.mod(3) == 0 } { \"% ist durch 3 teilbar\".postf(n) } { true } { \"% ist durch 7, 5 und 3 nicht teilbar\".postf(n) } ) \u00dcbung: Tonart-Erkennung Schreiben Sie mithilfe von case eine Funktion, die als Argument eine Sequenz von MIDI-Notennummern erh\u00e4lt. Das Programm soll diese Sequenz intervalle analysieren. Wenn diese Sequenz einer Dur- oder Moll-Tonleiter ( nat\u00fcrliches , harmonisches oder melodisches Moll, alle in aufsteigender Form) entspricht, soll die Funktion den Namen der Tonleiter als einen String zur\u00fcckgeben. Andernfalls soll der String \"Keine erkennbare Tonleiter\" zur\u00fcckgegeben werden. Tipp: Folgende Definitionen k\u00f6nnen Ihnen bei der Aufgabe n\u00fctzlich sein: ( // Die Intervallmuster der Dur-Tonleiter und drei Varianten der Moll-Tonleiter ~majorIntervals = [ 2, 2, 1, 2, 2, 2, 1 ]; ~nat_minorIntervals = [ 2, 1, 2, 2, 1, 2, 2 ]; ~harm_minorIntervals = [ 2, 1, 2, 2, 1, 3, 1 ]; ~mel_minorIntervals = [ 2, 1, 2, 2, 2, 2, 1 ]; // Bekommt ein Array von Zahlen (arg nums) und gibt ein Array von // Intervallen zwischen zwei benachbarten Zahlen aus ~getIntervals = { arg nums; var intervals = Array.new(nums.size - 1); nums.doAdjacentPairs({arg a, b; intervals.add(b - a)}); intervals } ) Tipp: Die Funktion midiname erh\u00e4lt eine Zahl und gibt den Namen der MIDI-Nummer als einen String aus. Tipp: String-Konkatenation k\u00f6nnen wir mit dem ++ -Operator erreichen: \"Super\" ++ \"Collider\" // -> \"SuperCollider\" F\u00fcr weitere Informationen zu Kontrollstrukturen suchen Sie in der Dokumentation nach \"Control Structures\" ( Ctrl+Shift+D und nach dem Begriff suchen).","title":"case"},{"location":"lit/","text":"Literatur Auf dieser Seite wird auf einige lesenswerte Artikel und B\u00fccher mit Themenschwerpunkten im Bereich der elektronischen und algorithmischen Musik verwiesen. Artikel W. Meyer-Eppler: Elektronische Kompositionstechnik (1953) H. Eimert, Der Sinus-Ton (1954) B\u00fccher G. Nierhaus: Algorithmic Composition, Paradigms of Automated Music Generation","title":"Literatur"},{"location":"lit/#literatur","text":"Auf dieser Seite wird auf einige lesenswerte Artikel und B\u00fccher mit Themenschwerpunkten im Bereich der elektronischen und algorithmischen Musik verwiesen.","title":"Literatur"},{"location":"lit/#artikel","text":"W. Meyer-Eppler: Elektronische Kompositionstechnik (1953) H. Eimert, Der Sinus-Ton (1954)","title":"Artikel"},{"location":"lit/#bucher","text":"G. Nierhaus: Algorithmic Composition, Paradigms of Automated Music Generation","title":"B\u00fccher"},{"location":"loesungen/","text":"\u00dcbungsl\u00f6sungen \u00dcbung: Simulation des Klanges einer Klarinette ( { // Grundfrequenz (mit der Mousebewegung auf der X-Achse kontrollierbar) var f0 = MouseX.kr(20, 200).round(20); // Anzahl der Partialt\u00f6ne var sz = 10; Mix.new( SinOsc.ar( freq: f0 * Array.series(sz, 1, 2), mul: Array.geom(sz, 0.5, 0.5) ) ) }.play ) Anpassen der Wartezeit zuf\u00e4llig zwischen 100 und 500 Millisekunden (in Sekunden ausgedr\u00fcckt: 0,1 und 0,5 Sekunden) ( Routine { (Array.series(20, 1) * 110).do { arg freq; freq.postln; Synth(\\meinSynth, [freq: freq, dur: 0.5]); // Wartezeit nach jedem Ton 0.1.rrand(0.5).wait } }.play )","title":"Instrumente definieren mit SynthDef"},{"location":"loesungen/#ubungslosungen","text":"","title":"\u00dcbungsl\u00f6sungen"},{"location":"loesungen/#ubung-simulation-des-klanges-einer-klarinette","text":"( { // Grundfrequenz (mit der Mousebewegung auf der X-Achse kontrollierbar) var f0 = MouseX.kr(20, 200).round(20); // Anzahl der Partialt\u00f6ne var sz = 10; Mix.new( SinOsc.ar( freq: f0 * Array.series(sz, 1, 2), mul: Array.geom(sz, 0.5, 0.5) ) ) }.play )","title":"\u00dcbung: Simulation des Klanges einer Klarinette"},{"location":"loesungen/#anpassen-der-wartezeit-zufallig-zwischen-100-und-500-millisekunden-in-sekunden-ausgedruckt-01-und-05-sekunden","text":"( Routine { (Array.series(20, 1) * 110).do { arg freq; freq.postln; Synth(\\meinSynth, [freq: freq, dur: 0.5]); // Wartezeit nach jedem Ton 0.1.rrand(0.5).wait } }.play )","title":"Anpassen der Wartezeit zuf\u00e4llig zwischen 100 und 500 Millisekunden (in Sekunden ausgedr\u00fcckt: 0,1 und 0,5 Sekunden)"},{"location":"seq/","text":"Sequenzierung Routine Das Abspielen mehrerer Synth-Instanzen mit einfachen Iterationsm\u00f6glichkeiten wie do und collect f\u00fchrt zwangsl\u00e4ufig zu Akkorden, da wir mit do / collect -Konstruktionen keine M\u00f6glichkeit zum sequenziellen Abspielen der Synth-Instanzen haben (diese werden praktisch gleichzeitig ausgef\u00fchrt). Mit der Klasse Routine k\u00f6nnen wir dies erreichen: Eine Routine ist im Grunde genommen eine Funktion, deren Ausf\u00fchrung wir mitten in der Auff\u00fchrung f\u00fcr eine beliebige Zeit pausieren k\u00f6nnen. Um eine Routine zu schreiben, m\u00fcssen wir lediglich den Iterationscode innerhalb der Routine einsetzen und an der passenden Stelle bestimmen, wie lange unsere Routine nach jeder Iteration warten soll, bevor die n\u00e4chste Iteration einsetzt. Dies geschieht mit Hilfe der wait -Methode. Am Ende m\u00fcssen wir unsere fertige Routine mithilfe der play -Methode starten. Eine fertige Routine sieht folgenderma\u00dfen aus; hier spielen wir die ersten 20 Partialt\u00f6ne der Grundfrequenz 110 Hz in einer Sequenz, wobei wir nach jedem Ton 150 Millisekunden warten ( 0.15.wait ): ( Routine { (Array.series(20, 1) * 110).do { arg freq; freq.postln; Synth(\\meinSynth, [freq: freq, dur: 0.5]); 0.15.wait } }.play ) \u00dcbung Ver\u00e4ndern Sie die Parameter der obigen Routine, wie zum Beispiel das Array von Frequenzen, \u00fcber das wir iterieren wollen. Passen Sie die Wartezeit der Routine an, sodass diese einen zuf\u00e4lligen Wert zwischen 100 Millisekunden und 500 Millisekunden annimmt (Stichwort rrand ). In der Tat kann man mit der next -Methode den n\u00e4chsten Wert einer Routine abrufen. Dies erm\u00f6glicht uns, auch unendliche Sequenzen nach bestimmten Mustern zu generieren. Im folgenden Beispiel definieren wir unsere Funktion aus dem Kapitel (?) zur Generierung der Fibonacci-Zahlen. Hierbei gestalten wir die Funktion jedoch so, dass wir mit einer inf.do eine unendliche Iteration starten ( inf steht f\u00fcr Infinite und ist ein von SuperCollider definierter Begriff). Die unendliche Iteration wird jedoch hier durch yield unterbrochen. yield funktioniert synonym zu wait und gibt einen Zwischenwert der Funktion zur\u00fcck: ( // Die Funktion zum Generieren der Fibonacci Sequenz ~fibGen = { var a=0, b=1; var tmpA = a; inf.do { a.yield; a = b; b = tmpA + b; tmpA = a; } } ); ~fibs = Routine(~fibGen) Man kann nun mithilfe der next -Methode die einzelnen Werte unserer Routine abfragen: // Evaluieren Sie die folgende Zeile mehrmals ~fibs.next; /* -> 0 -> 1 -> 1 -> 2 -> 3 -> 5 -> 8 -> 13 -> 21 -> 34 -> 55 -> 89 -> 144 -> 233 -> 377 -> 610 -> 987 -> 1597 usw. */ Eine Routine kann au\u00dferdem gestoppt werden, indem man die stop -Methode verwendet: // Nach der Evaluierung dieser Zeile hat unsere Routine keine Werte mehr zum Zur\u00fcckgeben ~fibs.stop und sie kann durch die reset -Methode zur\u00fcckgesetzt werden: // Durch die `reset`-Methode k\u00f6nnen wir immer wieder zum Anfang zur\u00fcck springen. // Evaluieren Sie die reset- und anschlie\u00dfend die next-Methode ~fibs.reset ~fibs.next Die Klasse Routine erbt die Methode play von der abstrakten Klasse Stream (eine Klasse, die wir nie direkt verwenden werden, sondern nur f\u00fcr die Definition weiterer Klassen vorgesehen ist). Die Methode play funktioniert im Wesentlichen wie das wiederholte Aufrufen der Methode next , bis die Routine ersch\u00f6pft ist und nil zur\u00fcckgibt. Zu diesem Zeitpunkt wird das weitere Abrufen von Werten gestoppt. \u00c4hnlich wie im oben genannten Fibonacci-Beispiel k\u00f6nnen wir den Fortschritt der Werteberechnungen in einer Schleife (wie beispielsweise do ) verpacken und dabei entsprechende wait - oder yield -Anweisungen an geeigneten Stellen einf\u00fcgen: ( Routine { 5.do { arg i; i.postln; \" +\".postln; 1.wait; \" -\".postln; 1.wait; }; \"Ende\".postln }.play ) /* -> a Routine 0 + - 1 + - 2 + - 3 + - 4 + - Ende */ oder wir k\u00f6nnen die Eingabewerte von yield als Wartezeit interpretieren: Wenn die Eingabe f\u00fcr yield eine Zahl ist, wird diese automatisch als Wartezeit interpretiert. Es wird so lange gewartet, bis der n\u00e4chste Aufruf der next -Methode stattfindet: ( Routine { 0.25.postln.yield; 0.5.postln.yield; 1.postln.yield; 2.postln.yield; 4.postln.yield; \"Ende\".postln }.play ) /* -> a Routine 0.25 0.5 1 2 4 Ende */","title":"Sequenzierung"},{"location":"seq/#sequenzierung","text":"","title":"Sequenzierung"},{"location":"seq/#routine","text":"Das Abspielen mehrerer Synth-Instanzen mit einfachen Iterationsm\u00f6glichkeiten wie do und collect f\u00fchrt zwangsl\u00e4ufig zu Akkorden, da wir mit do / collect -Konstruktionen keine M\u00f6glichkeit zum sequenziellen Abspielen der Synth-Instanzen haben (diese werden praktisch gleichzeitig ausgef\u00fchrt). Mit der Klasse Routine k\u00f6nnen wir dies erreichen: Eine Routine ist im Grunde genommen eine Funktion, deren Ausf\u00fchrung wir mitten in der Auff\u00fchrung f\u00fcr eine beliebige Zeit pausieren k\u00f6nnen. Um eine Routine zu schreiben, m\u00fcssen wir lediglich den Iterationscode innerhalb der Routine einsetzen und an der passenden Stelle bestimmen, wie lange unsere Routine nach jeder Iteration warten soll, bevor die n\u00e4chste Iteration einsetzt. Dies geschieht mit Hilfe der wait -Methode. Am Ende m\u00fcssen wir unsere fertige Routine mithilfe der play -Methode starten. Eine fertige Routine sieht folgenderma\u00dfen aus; hier spielen wir die ersten 20 Partialt\u00f6ne der Grundfrequenz 110 Hz in einer Sequenz, wobei wir nach jedem Ton 150 Millisekunden warten ( 0.15.wait ): ( Routine { (Array.series(20, 1) * 110).do { arg freq; freq.postln; Synth(\\meinSynth, [freq: freq, dur: 0.5]); 0.15.wait } }.play ) \u00dcbung Ver\u00e4ndern Sie die Parameter der obigen Routine, wie zum Beispiel das Array von Frequenzen, \u00fcber das wir iterieren wollen. Passen Sie die Wartezeit der Routine an, sodass diese einen zuf\u00e4lligen Wert zwischen 100 Millisekunden und 500 Millisekunden annimmt (Stichwort rrand ). In der Tat kann man mit der next -Methode den n\u00e4chsten Wert einer Routine abrufen. Dies erm\u00f6glicht uns, auch unendliche Sequenzen nach bestimmten Mustern zu generieren. Im folgenden Beispiel definieren wir unsere Funktion aus dem Kapitel (?) zur Generierung der Fibonacci-Zahlen. Hierbei gestalten wir die Funktion jedoch so, dass wir mit einer inf.do eine unendliche Iteration starten ( inf steht f\u00fcr Infinite und ist ein von SuperCollider definierter Begriff). Die unendliche Iteration wird jedoch hier durch yield unterbrochen. yield funktioniert synonym zu wait und gibt einen Zwischenwert der Funktion zur\u00fcck: ( // Die Funktion zum Generieren der Fibonacci Sequenz ~fibGen = { var a=0, b=1; var tmpA = a; inf.do { a.yield; a = b; b = tmpA + b; tmpA = a; } } ); ~fibs = Routine(~fibGen) Man kann nun mithilfe der next -Methode die einzelnen Werte unserer Routine abfragen: // Evaluieren Sie die folgende Zeile mehrmals ~fibs.next; /* -> 0 -> 1 -> 1 -> 2 -> 3 -> 5 -> 8 -> 13 -> 21 -> 34 -> 55 -> 89 -> 144 -> 233 -> 377 -> 610 -> 987 -> 1597 usw. */ Eine Routine kann au\u00dferdem gestoppt werden, indem man die stop -Methode verwendet: // Nach der Evaluierung dieser Zeile hat unsere Routine keine Werte mehr zum Zur\u00fcckgeben ~fibs.stop und sie kann durch die reset -Methode zur\u00fcckgesetzt werden: // Durch die `reset`-Methode k\u00f6nnen wir immer wieder zum Anfang zur\u00fcck springen. // Evaluieren Sie die reset- und anschlie\u00dfend die next-Methode ~fibs.reset ~fibs.next Die Klasse Routine erbt die Methode play von der abstrakten Klasse Stream (eine Klasse, die wir nie direkt verwenden werden, sondern nur f\u00fcr die Definition weiterer Klassen vorgesehen ist). Die Methode play funktioniert im Wesentlichen wie das wiederholte Aufrufen der Methode next , bis die Routine ersch\u00f6pft ist und nil zur\u00fcckgibt. Zu diesem Zeitpunkt wird das weitere Abrufen von Werten gestoppt. \u00c4hnlich wie im oben genannten Fibonacci-Beispiel k\u00f6nnen wir den Fortschritt der Werteberechnungen in einer Schleife (wie beispielsweise do ) verpacken und dabei entsprechende wait - oder yield -Anweisungen an geeigneten Stellen einf\u00fcgen: ( Routine { 5.do { arg i; i.postln; \" +\".postln; 1.wait; \" -\".postln; 1.wait; }; \"Ende\".postln }.play ) /* -> a Routine 0 + - 1 + - 2 + - 3 + - 4 + - Ende */ oder wir k\u00f6nnen die Eingabewerte von yield als Wartezeit interpretieren: Wenn die Eingabe f\u00fcr yield eine Zahl ist, wird diese automatisch als Wartezeit interpretiert. Es wird so lange gewartet, bis der n\u00e4chste Aufruf der next -Methode stattfindet: ( Routine { 0.25.postln.yield; 0.5.postln.yield; 1.postln.yield; 2.postln.yield; 4.postln.yield; \"Ende\".postln }.play ) /* -> a Routine 0.25 0.5 1 2 4 Ende */","title":"Routine"},{"location":"synth/","text":"Einf\u00fchrung in Synth Instrumente definieren mit SynthDef In diesem Kapitel lernen wir die Kernelemente der Klanggenerierung auf dem SuperCollider-Server kennen. Diese tragen den Namen \"Synth\" (f\u00fcr Synthesize). Jedes Mal, wenn wir in unserem letzten Kapitel eine Funktion mit einer SinOsc UGen abgespielt haben, hat der SuperCollider-Server hinter den Kulissen einen Synth generiert. Das konnten wir auch im Post-Fenster sehen, wenn wir auf unsere Funktion die Methode play angewendet haben: {SinOsc.ar(mul: 0.2)}.play Im Post-Fenster sehen wir etwas wie -> Synth('temp__0' : 1000) , eine Darstellung des frisch f\u00fcr uns generierten Synths, der hier den Namen temp__0 und eine ID-Nummer 1000 tr\u00e4gt (Dies kann bei Ihnen anders aussehen). Wenn wir unsere Funktionsargumente definieren, k\u00f6nnen wir mit dem entstehenden Synth kommunizieren: y = {arg freq=440, amp=0.2; SinOsc.ar(freq: freq, mul: amp)}.play Eine Ver\u00e4nderung der Frequenz: y.set(\\freq, 330) oder Ver\u00e4nderung der Amplitude: y.set(\\amp, 0.2) k\u00f6nnen wir durch die set Methode der Synth-Klasse vornehmen. Wir lassen unseren Synth geschmeidig \u00fcber eine Sekunde ausklingen: y.release(1) Wir definieren einen \u00e4hnlichen Synth selbst! Das Erstellen von Synths geschieht durch die SynthDef-Klasse, wie folgt. Evaluieren Sie den folgenden Block. Im Post-Fenster sehen wir, dass unser Synth erfolgreich f\u00fcr den Server definiert wurde ( -> SynthDef:meinSynth ): ( SynthDef(\\meinSynth, { arg freq=440, amp=0.2; Out.ar(0, SinOsc.ar(freq: freq, mul: amp)) }).add ) Ich gehe jede Zeile der obigen Synth-Definition durch: ( // Mit der SynthDef-Klasse definieren wir den Synth. Das erste Argument ist der Name, den wir unserem // Synth geben m\u00f6chten (hier meinSynth). Dieses Argument kann entweder vom Typ Symbol sein (wie \\meinSynth) oder ein String (wie \"meinSynth\"). SynthDef(\\meinSynth, // Das zweite Argument ist eine Funktion, die definiert, wie wir Ugens zusammen kombinieren // m\u00f6chten, um unser Instrument zu bauen. { // Argumente f\u00fcr die Funktion. arg freq=440, amp=0.2; // Es gibt hier einen gro\u00dfen Unterschied zu unserer {}.play Form fr\u00fcher. Da hatte f\u00fcr uns // SuperCollider entschieden, dass unser Signal zum ersten (linken) Kanal rausgeschickt wird. // Beim Definieren eines Instruments durch SynthDef m\u00fcssen wir dem Instrument genau mitteilen, // zu welchem Ausgang unser Signal rausgeschickt werden soll. Daf\u00fcr nutzen wir ein UGen // namens Out und instanzieren es mit der ar Methode. Das erste Argument dazu bestimmt // die Nummer des Ausgangskanals (mit 0 f\u00fcr ersten Kanal, 1 f\u00fcr zweiten Kanal usw.). Das // zweite Argument bestimmt das eigentliche Signal (also wie unser Instrument klingen wird). Out.ar(0, SinOsc.ar(freq: freq, mul: amp)) } // Nachdem wir mit der Definition unserer Synth-Funktion fertig sind, m\u00fcssen wir durch // die add Methode unser Instrument der Liste der f\u00fcr den Server bekannten Synths // hinzuf\u00fcgen: ).add ) Ab jetzt k\u00f6nnen wir unser Instrument zum Erklingen bringen (wir geben unserer Synth-Instanz den Namen x , damit wir die Parameter des Instruments mit set modifizieren k\u00f6nnen). Daf\u00fcr schreiben wir: x = Synth(\\meinSynth) x.set(\\freq, 220) x.set(\\amp, 0.1) x.free x.defName // -> meinSynth Sinnvollerweise sind wir in der Lage, den Ausgangskanal (das erste Argument zu dem Out Ugen) ebenfalls als ein Argument f\u00fcr unsere Synth-Funktion zu definieren. So k\u00f6nnen wir f\u00fcr jede einzelne Instanz unseres Instruments einen anderen physischen Kanal ausw\u00e4hlen. Daf\u00fcr modifiziere ich die obige Definition folgenderma\u00dfen: ( SynthDef(\\meinSynth, { arg freq=440, amp=0.2, kanal=0; Out.ar(kanal, SinOsc.ar(freq: freq, mul: amp)) }).add ) Jetzt k\u00f6nnen wir das Signal von links nach rechts schicken: x = Synth(\\meinSynth) x.set(\\kanal, 1) x.free Die Synth-Klasse erlaubt es uns, die Argumente unserer Synth-Funktion schon beim Kreieren des Instruments zu \u00fcbergeben. Daf\u00fcr \u00fcbergeben wir als das zweite Argument zum Synth ein Array mit Namen der Funktionsargumente (als Symbole oder Strings) und die Werte, getrennt durch Komma: Synth(\\meinSynth, [\\freq, 220, \\amp, 0.1, \\kanal, 1]) Wir k\u00f6nnen durch mehrere Instanzen unseres Instruments mit jeweils unterschiedlichen Parametern erstellen. \u00dcbung: Evaluieren Sie den folgenden Block. Versuchen Sie zu beschreiben, was dort passiert: ( var n = 40; n.do { arg x; Synth(\\meinSynth, [\\freq, 220 + (x * 2), \\amp, n.reciprocal, \\kanal: 0.rrand(1)]) } ) \u00dcbung: Interferenz zweier naher Frequenzen Nutzen Sie unser Wissen aus dem letzten Kapitel \u00fcber die Mehrkanalerweiterung, um ein Instrument zu definieren, das auf den rechten und linken Kan\u00e4len zwei leicht unterschiedliche Frequenzen erklingen l\u00e4sst. Verwenden Sie daf\u00fcr den UGen \"Saw\" (ein S\u00e4gezahn-Oszillator). Verwenden Sie f\u00fcr den linken Kanal eine Frequenz von 40 Hz und auf dem rechten Kanal eine Frequenz von 41 Hz. Setzen Sie die Amplitude des S\u00e4gezahns auf den Wert 0.2.","title":"Instrumente definieren mit SynthDef"},{"location":"synth/#einfuhrung-in-synth","text":"","title":"Einf\u00fchrung in Synth"},{"location":"synth/#instrumente-definieren-mit-synthdef","text":"In diesem Kapitel lernen wir die Kernelemente der Klanggenerierung auf dem SuperCollider-Server kennen. Diese tragen den Namen \"Synth\" (f\u00fcr Synthesize). Jedes Mal, wenn wir in unserem letzten Kapitel eine Funktion mit einer SinOsc UGen abgespielt haben, hat der SuperCollider-Server hinter den Kulissen einen Synth generiert. Das konnten wir auch im Post-Fenster sehen, wenn wir auf unsere Funktion die Methode play angewendet haben: {SinOsc.ar(mul: 0.2)}.play Im Post-Fenster sehen wir etwas wie -> Synth('temp__0' : 1000) , eine Darstellung des frisch f\u00fcr uns generierten Synths, der hier den Namen temp__0 und eine ID-Nummer 1000 tr\u00e4gt (Dies kann bei Ihnen anders aussehen). Wenn wir unsere Funktionsargumente definieren, k\u00f6nnen wir mit dem entstehenden Synth kommunizieren: y = {arg freq=440, amp=0.2; SinOsc.ar(freq: freq, mul: amp)}.play Eine Ver\u00e4nderung der Frequenz: y.set(\\freq, 330) oder Ver\u00e4nderung der Amplitude: y.set(\\amp, 0.2) k\u00f6nnen wir durch die set Methode der Synth-Klasse vornehmen. Wir lassen unseren Synth geschmeidig \u00fcber eine Sekunde ausklingen: y.release(1) Wir definieren einen \u00e4hnlichen Synth selbst! Das Erstellen von Synths geschieht durch die SynthDef-Klasse, wie folgt. Evaluieren Sie den folgenden Block. Im Post-Fenster sehen wir, dass unser Synth erfolgreich f\u00fcr den Server definiert wurde ( -> SynthDef:meinSynth ): ( SynthDef(\\meinSynth, { arg freq=440, amp=0.2; Out.ar(0, SinOsc.ar(freq: freq, mul: amp)) }).add ) Ich gehe jede Zeile der obigen Synth-Definition durch: ( // Mit der SynthDef-Klasse definieren wir den Synth. Das erste Argument ist der Name, den wir unserem // Synth geben m\u00f6chten (hier meinSynth). Dieses Argument kann entweder vom Typ Symbol sein (wie \\meinSynth) oder ein String (wie \"meinSynth\"). SynthDef(\\meinSynth, // Das zweite Argument ist eine Funktion, die definiert, wie wir Ugens zusammen kombinieren // m\u00f6chten, um unser Instrument zu bauen. { // Argumente f\u00fcr die Funktion. arg freq=440, amp=0.2; // Es gibt hier einen gro\u00dfen Unterschied zu unserer {}.play Form fr\u00fcher. Da hatte f\u00fcr uns // SuperCollider entschieden, dass unser Signal zum ersten (linken) Kanal rausgeschickt wird. // Beim Definieren eines Instruments durch SynthDef m\u00fcssen wir dem Instrument genau mitteilen, // zu welchem Ausgang unser Signal rausgeschickt werden soll. Daf\u00fcr nutzen wir ein UGen // namens Out und instanzieren es mit der ar Methode. Das erste Argument dazu bestimmt // die Nummer des Ausgangskanals (mit 0 f\u00fcr ersten Kanal, 1 f\u00fcr zweiten Kanal usw.). Das // zweite Argument bestimmt das eigentliche Signal (also wie unser Instrument klingen wird). Out.ar(0, SinOsc.ar(freq: freq, mul: amp)) } // Nachdem wir mit der Definition unserer Synth-Funktion fertig sind, m\u00fcssen wir durch // die add Methode unser Instrument der Liste der f\u00fcr den Server bekannten Synths // hinzuf\u00fcgen: ).add ) Ab jetzt k\u00f6nnen wir unser Instrument zum Erklingen bringen (wir geben unserer Synth-Instanz den Namen x , damit wir die Parameter des Instruments mit set modifizieren k\u00f6nnen). Daf\u00fcr schreiben wir: x = Synth(\\meinSynth) x.set(\\freq, 220) x.set(\\amp, 0.1) x.free x.defName // -> meinSynth Sinnvollerweise sind wir in der Lage, den Ausgangskanal (das erste Argument zu dem Out Ugen) ebenfalls als ein Argument f\u00fcr unsere Synth-Funktion zu definieren. So k\u00f6nnen wir f\u00fcr jede einzelne Instanz unseres Instruments einen anderen physischen Kanal ausw\u00e4hlen. Daf\u00fcr modifiziere ich die obige Definition folgenderma\u00dfen: ( SynthDef(\\meinSynth, { arg freq=440, amp=0.2, kanal=0; Out.ar(kanal, SinOsc.ar(freq: freq, mul: amp)) }).add ) Jetzt k\u00f6nnen wir das Signal von links nach rechts schicken: x = Synth(\\meinSynth) x.set(\\kanal, 1) x.free Die Synth-Klasse erlaubt es uns, die Argumente unserer Synth-Funktion schon beim Kreieren des Instruments zu \u00fcbergeben. Daf\u00fcr \u00fcbergeben wir als das zweite Argument zum Synth ein Array mit Namen der Funktionsargumente (als Symbole oder Strings) und die Werte, getrennt durch Komma: Synth(\\meinSynth, [\\freq, 220, \\amp, 0.1, \\kanal, 1]) Wir k\u00f6nnen durch mehrere Instanzen unseres Instruments mit jeweils unterschiedlichen Parametern erstellen. \u00dcbung: Evaluieren Sie den folgenden Block. Versuchen Sie zu beschreiben, was dort passiert: ( var n = 40; n.do { arg x; Synth(\\meinSynth, [\\freq, 220 + (x * 2), \\amp, n.reciprocal, \\kanal: 0.rrand(1)]) } ) \u00dcbung: Interferenz zweier naher Frequenzen Nutzen Sie unser Wissen aus dem letzten Kapitel \u00fcber die Mehrkanalerweiterung, um ein Instrument zu definieren, das auf den rechten und linken Kan\u00e4len zwei leicht unterschiedliche Frequenzen erklingen l\u00e4sst. Verwenden Sie daf\u00fcr den UGen \"Saw\" (ein S\u00e4gezahn-Oszillator). Verwenden Sie f\u00fcr den linken Kanal eine Frequenz von 40 Hz und auf dem rechten Kanal eine Frequenz von 41 Hz. Setzen Sie die Amplitude des S\u00e4gezahns auf den Wert 0.2.","title":"Instrumente definieren mit SynthDef"}]}