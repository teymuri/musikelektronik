{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Elektronische Musik / Musik-Elektronik Modul Kernfach Theorie III Das Ziel dieser \u00dcbung ist das Kennenlernen und Erproben der M\u00f6glichkeiten der elektronischen Musik in Theorie und Praxis anhand eines gemeinsam zu erarbeitenden Musikbeispiels. Die Analyse von Werken aus dem Repertoire ist ebenfalls ein Schwerpunkt dieses Seminars. Titel (dt.) der konkreten Lehrveranstaltung: Elektronische Musik + Musik-Elektronik Veranstaltungsart: \u00dcbung (anmeldepflichtig) Semesterwochenstunden (SWS): 2 Leistungspunkte (ECTS): 2 Das Modul beginnt jeweils im Wintersemester und erstreckt sich \u00fcber zwei Semester. Bitte f\u00fchren Sie die Code-Beispiele in Ihrer SuperCollider-Umgebung aus und evaluieren Sie diese, um sich schneller mit dem Arbeitsverfahren in SuperCollider vertraut zu machen. Die Bearbeitung der \u00dcbungen in den Kapiteln wird ausdr\u00fccklich empfohlen. Bei Fragen wenden Sie sich bitte an das Lehrpersonal.","title":"Modulbeschreibung"},{"location":"#elektronische-musik-musik-elektronik","text":"","title":"Elektronische Musik / Musik-Elektronik"},{"location":"#modul-kernfach-theorie-iii","text":"Das Ziel dieser \u00dcbung ist das Kennenlernen und Erproben der M\u00f6glichkeiten der elektronischen Musik in Theorie und Praxis anhand eines gemeinsam zu erarbeitenden Musikbeispiels. Die Analyse von Werken aus dem Repertoire ist ebenfalls ein Schwerpunkt dieses Seminars. Titel (dt.) der konkreten Lehrveranstaltung: Elektronische Musik + Musik-Elektronik Veranstaltungsart: \u00dcbung (anmeldepflichtig) Semesterwochenstunden (SWS): 2 Leistungspunkte (ECTS): 2 Das Modul beginnt jeweils im Wintersemester und erstreckt sich \u00fcber zwei Semester. Bitte f\u00fchren Sie die Code-Beispiele in Ihrer SuperCollider-Umgebung aus und evaluieren Sie diese, um sich schneller mit dem Arbeitsverfahren in SuperCollider vertraut zu machen. Die Bearbeitung der \u00dcbungen in den Kapiteln wird ausdr\u00fccklich empfohlen. Bei Fragen wenden Sie sich bitte an das Lehrpersonal.","title":"Modul Kernfach Theorie III"},{"location":"first_sounds/","text":"Die ersten T\u00f6ne Starten des Servers Im letzten Kapitel haben wir uns mit der Sprache SuperCollider besch\u00e4ftigt. Die Sprache allein kann keinen Klang erzeugen, sondern ist lediglich f\u00fcr die Weitergabe unserer Befehle an den Klang-Server verantwortlich. Um unseren ersten Ton in SuperCollider zu erzeugen, m\u00fcssen wir zuerst den Server starten. Erinnern wir uns daran, dass die Einzelvariabel \"s\" f\u00fcr den Server steht. Mit dem Aufrufen des boot -Befehls starten wir ihn: s.boot; Aus historischen Gr\u00fcnden werden in SuperCollider auch die Objekte, die f\u00fcr die Klangerzeugung verantwortlich sind, als \"UGen\" bezeichnet. Eine dieser UGens ist SinOsc, die eine einfache Sinusschwingung generiert. Die meisten UGens in SuperCollider ben\u00f6tigen Informationen von uns (\u00e4hnlich wie Argumente in Funktionen im letzten Kapitel). Zum Beispiel ben\u00f6tigt unser SinOsc UGen folgende Eingaben: Frequenz, Phase, Amplitude und DC-Offset. Geben Sie den folgenden Code in Ihren SuperCollider-Editor ein. Sobald Sie die Klammer \u00f6ffnen, sollten Sie diese Argumente sehen k\u00f6nnen. Achten Sie darauf, dass diese Argumente auch Standardwerte haben, so dass, wenn wir keine Informationen bereitstellen, diese Standardwerte \u00fcbernommen werden: SinOsc.ar(); (Tipp: Wenn die Argumentenliste nicht angezeigt wird, kann man sie durch Dr\u00fccken der Tastenkombination Shift+Ctrl+L wieder einblenden.) Im Kontext von SuperCollider steuern die Argumente des SinOsc (Sinus Oszillator) die Eigenschaften der erzeugten Sinusschwingung. Hier sind die Argumente: Frequenz (freq): Dies bestimmt, wie viele Schwingungen pro Sekunde erzeugt werden. Eine h\u00f6here Frequenz erzeugt einen h\u00f6heren Ton. Phase (phase): Die Phase gibt den Startpunkt der Sinusschwingung an. Eine Phase von 0 bedeutet, dass die Schwingung bei null Grad beginnt. Amplitude (mul): Die Amplitude beeinflusst die H\u00f6he der Schwingung und damit die Lautst\u00e4rke des Tons. Eine h\u00f6here Amplitude erzeugt einen lauter klingenden Ton (Werte zwischen 0 und 1). DC-Offset (add): Dies ist eine konstante Spannung, die zur Sinuswelle hinzugef\u00fcgt wird. Sie beeinflusst den Grundpegel der Welle und kann dazu verwendet werden, sicherzustellen, dass die Welle um den Nullpunkt zentriert ist oder einen bestimmten Ausgangspunkt hat. Der Code SinOsc.ar() erzeugt standardm\u00e4\u00dfig eine Sinusschwingung mit den Standardwerten f\u00fcr Frequenz, Phase, Amplitude und DC-Offset. Wenn Sie spezifische Werte angeben m\u00f6chten, k\u00f6nnen Sie sie als Argumente im SinOsc-Objekt setzen, z.B. SinOsc.ar(440, 0, 0.5, 0) , wobei 440 die Frequenz, 0 die Phase, 0.5 die Amplitude und 0 das DC-Offset ist. Um nun den Klang einer 440-Hz-Frequenz zu h\u00f6ren, m\u00fcssen wir unsere UGens in eine Funktion einbetten und die play -Nachricht an diese Funktion senden. Dadurch wird die enthaltene UGen an den Server gesendet, und wir k\u00f6nnen etwas h\u00f6ren. Bevor wir weitermachen und den ersten Sinuston an den Server senden, ist es wichtig zu wissen, wie wir den Ton wieder ausschalten k\u00f6nnen. Merken Sie sich die Tastenkombination Ctrl+. Dies deaktiviert den Server, und wir nutzen momentan diese Methode, um den Ton schnell auszuschalten. Schreiben Sie nun den folgenden Code-Block und f\u00fchren Sie ihn aus (mit dem Cursor innerhalb des Blocks Ctrl+Enter dr\u00fccken): {SinOsc.ar(440, 0, 0.5, 0)}.play; Stoppen Sie den Server mit Ctrl+. und lassen Sie uns den obigen Code etwas genauer betrachten. Wir \u00f6ffnen zuerst mit den runden Klammern einen Block. Dies ist praktisch, wenn unser Code \u00fcber mehrere Zeilen geht, damit wir alle Zeilen auf einmal auswerten k\u00f6nnen. () Als N\u00e4chstes \u00f6ffnen wir ein paar geschweifte Klammern, um eine anonyme Funktion zu definieren. Sie ist anonym, weil wir diese Funktion nur an dieser Stelle als Beispiel verwenden und ihr keinen Namen geben: ({}) Innerhalb unserer Funktion schreiben wir unsere UGen mit den gew\u00fcnschten Argumenten: ({SinOsc.ar(440, 0, 0.5, 0)}) Auf das Objekt SinOsc wenden wir die Nachricht ar an, die f\u00fcr Audio Rate steht. Die ar -Funktion sorgt daf\u00fcr, dass die Sample-Ausgaben der UGen (hier SinOsc) in einer Audiorate (oft 44100 Mal pro Sekunde) vom Server an die Audiokarten unseres Rechners geschickt werden. Von dort werden diese Samples (die im Prinzip nichts anderes sind als Dezimalzahlen) an einen sogenannten DAC (Digital Audio Converter) geschickt, um dann als Spannungsvariationen (nach eventueller Verst\u00e4rkung) an Lautsprecher gesendet zu werden. Wichtig ist auch zu verstehen, dass die ar -Methode gleichzeitig eine Instanz der SinOsc-Klasse generiert. Wenn wir an dieser Stelle unseren Code-Block auswerten, sehen wir im Post-Fenster, dass er zu einer Funktion evaluiert wurde ( -> a Function ). Jetzt k\u00f6nnen wir unsere Funktion an den Server senden. Daf\u00fcr rufen wir die play -Methode auf die Funktion auf. Was wir hier \u00fcber die play -Methode einer Funktion wissen m\u00fcssen: play generiert auf dem Server einen sogenannten Synth. Synths sind die Klanggeneratoren auf der Server-Seite. Diese Synth wird nach der Erstellung zum Klingen gebracht: ({SinOsc.ar(440, 0, 0.5, 0)}.play) Wenn wir die tats\u00e4chliche Synth, die f\u00fcr uns von play generiert wurde, weiterhin kontrollieren m\u00f6chten (der serverinterne Name wird im Post-Fenster nach dem Auswerten der obigen Zeile angezeigt), k\u00f6nnen wir ganz einfach die ausgegebene Synth einer Variable zuweisen: (x = {SinOsc.ar(440, 0, 0.5, 0)}.play) Jetzt enth\u00e4lt x die Synth, und wir k\u00f6nnen sie zum Beispiel \u00fcber die Variable x ausschalten, indem wir der Variable x die Nachricht free senden: x.free; Das ist praktisch, da wir mit free nur diese eine Synth-Instanz abschalten k\u00f6nnen (im Unterschied zu unserer vorherigen L\u00f6sung Ctrl+. , die den kompletten Server herunterf\u00e4hrt). Wir k\u00f6nnen unserer Funktion Argumente hinzuf\u00fcgen, sodass wir die Parameter unseres SinOsc explizit eingeben k\u00f6nnen: ( x = { arg freq = 440, amp = 0.5; SinOsc.ar(freq, mul: amp) } ) So k\u00f6nnen wir durch die set -Methode unserer Synth-Instanzen die Frequenz oder die Amplitude neu setzen, und das w\u00e4hrend der Synth l\u00e4uft (also w\u00e4hrend unser Sinuston weiter erklingt): // Funktion abspielen x.play; // Amplitude halbieren x.set(\\amp, 0.25); // Die Frequenz um eine Oktave tiefer spielen x.set(\\freq, 220); Das Verst\u00e4ndnis eines Prinzips ist hier von Bedeutung: auch die UGens (wie alles andere auf unserem Rechner!) arbeiten ausschlie\u00dflich mit Zahlen! Das bedeutet, ihre Ausgabe besteht ausschlie\u00dflich aus Zahlen. Das erm\u00f6glicht es uns, eine weitere UGen als Argument f\u00fcr unsere SinOsc UGen einzusetzen. Dadurch wird ein kontinuierlicher Datenstrom an Zahlen an die Haupt-UGen gesendet, die dann als Frequenz (oder auch andere Parameter) interpretiert werden k\u00f6nnen. Ein Beispiel: ( { SinOsc.ar(SinOsc.kr(1, mul: 100, add: 400)) }.play ) Dieses Beispiel demonstriert, wie eine Sinus-Oszillation (SinOsc) mit einer anderen Sinus-Oszillation als Modulator f\u00fcr ihre Frequenz verwendet werden kann.","title":"Die ersten T\u00f6ne"},{"location":"first_sounds/#die-ersten-tone","text":"","title":"Die ersten T\u00f6ne"},{"location":"first_sounds/#starten-des-servers","text":"Im letzten Kapitel haben wir uns mit der Sprache SuperCollider besch\u00e4ftigt. Die Sprache allein kann keinen Klang erzeugen, sondern ist lediglich f\u00fcr die Weitergabe unserer Befehle an den Klang-Server verantwortlich. Um unseren ersten Ton in SuperCollider zu erzeugen, m\u00fcssen wir zuerst den Server starten. Erinnern wir uns daran, dass die Einzelvariabel \"s\" f\u00fcr den Server steht. Mit dem Aufrufen des boot -Befehls starten wir ihn: s.boot; Aus historischen Gr\u00fcnden werden in SuperCollider auch die Objekte, die f\u00fcr die Klangerzeugung verantwortlich sind, als \"UGen\" bezeichnet. Eine dieser UGens ist SinOsc, die eine einfache Sinusschwingung generiert. Die meisten UGens in SuperCollider ben\u00f6tigen Informationen von uns (\u00e4hnlich wie Argumente in Funktionen im letzten Kapitel). Zum Beispiel ben\u00f6tigt unser SinOsc UGen folgende Eingaben: Frequenz, Phase, Amplitude und DC-Offset. Geben Sie den folgenden Code in Ihren SuperCollider-Editor ein. Sobald Sie die Klammer \u00f6ffnen, sollten Sie diese Argumente sehen k\u00f6nnen. Achten Sie darauf, dass diese Argumente auch Standardwerte haben, so dass, wenn wir keine Informationen bereitstellen, diese Standardwerte \u00fcbernommen werden: SinOsc.ar(); (Tipp: Wenn die Argumentenliste nicht angezeigt wird, kann man sie durch Dr\u00fccken der Tastenkombination Shift+Ctrl+L wieder einblenden.) Im Kontext von SuperCollider steuern die Argumente des SinOsc (Sinus Oszillator) die Eigenschaften der erzeugten Sinusschwingung. Hier sind die Argumente: Frequenz (freq): Dies bestimmt, wie viele Schwingungen pro Sekunde erzeugt werden. Eine h\u00f6here Frequenz erzeugt einen h\u00f6heren Ton. Phase (phase): Die Phase gibt den Startpunkt der Sinusschwingung an. Eine Phase von 0 bedeutet, dass die Schwingung bei null Grad beginnt. Amplitude (mul): Die Amplitude beeinflusst die H\u00f6he der Schwingung und damit die Lautst\u00e4rke des Tons. Eine h\u00f6here Amplitude erzeugt einen lauter klingenden Ton (Werte zwischen 0 und 1). DC-Offset (add): Dies ist eine konstante Spannung, die zur Sinuswelle hinzugef\u00fcgt wird. Sie beeinflusst den Grundpegel der Welle und kann dazu verwendet werden, sicherzustellen, dass die Welle um den Nullpunkt zentriert ist oder einen bestimmten Ausgangspunkt hat. Der Code SinOsc.ar() erzeugt standardm\u00e4\u00dfig eine Sinusschwingung mit den Standardwerten f\u00fcr Frequenz, Phase, Amplitude und DC-Offset. Wenn Sie spezifische Werte angeben m\u00f6chten, k\u00f6nnen Sie sie als Argumente im SinOsc-Objekt setzen, z.B. SinOsc.ar(440, 0, 0.5, 0) , wobei 440 die Frequenz, 0 die Phase, 0.5 die Amplitude und 0 das DC-Offset ist. Um nun den Klang einer 440-Hz-Frequenz zu h\u00f6ren, m\u00fcssen wir unsere UGens in eine Funktion einbetten und die play -Nachricht an diese Funktion senden. Dadurch wird die enthaltene UGen an den Server gesendet, und wir k\u00f6nnen etwas h\u00f6ren. Bevor wir weitermachen und den ersten Sinuston an den Server senden, ist es wichtig zu wissen, wie wir den Ton wieder ausschalten k\u00f6nnen. Merken Sie sich die Tastenkombination Ctrl+. Dies deaktiviert den Server, und wir nutzen momentan diese Methode, um den Ton schnell auszuschalten. Schreiben Sie nun den folgenden Code-Block und f\u00fchren Sie ihn aus (mit dem Cursor innerhalb des Blocks Ctrl+Enter dr\u00fccken): {SinOsc.ar(440, 0, 0.5, 0)}.play; Stoppen Sie den Server mit Ctrl+. und lassen Sie uns den obigen Code etwas genauer betrachten. Wir \u00f6ffnen zuerst mit den runden Klammern einen Block. Dies ist praktisch, wenn unser Code \u00fcber mehrere Zeilen geht, damit wir alle Zeilen auf einmal auswerten k\u00f6nnen. () Als N\u00e4chstes \u00f6ffnen wir ein paar geschweifte Klammern, um eine anonyme Funktion zu definieren. Sie ist anonym, weil wir diese Funktion nur an dieser Stelle als Beispiel verwenden und ihr keinen Namen geben: ({}) Innerhalb unserer Funktion schreiben wir unsere UGen mit den gew\u00fcnschten Argumenten: ({SinOsc.ar(440, 0, 0.5, 0)}) Auf das Objekt SinOsc wenden wir die Nachricht ar an, die f\u00fcr Audio Rate steht. Die ar -Funktion sorgt daf\u00fcr, dass die Sample-Ausgaben der UGen (hier SinOsc) in einer Audiorate (oft 44100 Mal pro Sekunde) vom Server an die Audiokarten unseres Rechners geschickt werden. Von dort werden diese Samples (die im Prinzip nichts anderes sind als Dezimalzahlen) an einen sogenannten DAC (Digital Audio Converter) geschickt, um dann als Spannungsvariationen (nach eventueller Verst\u00e4rkung) an Lautsprecher gesendet zu werden. Wichtig ist auch zu verstehen, dass die ar -Methode gleichzeitig eine Instanz der SinOsc-Klasse generiert. Wenn wir an dieser Stelle unseren Code-Block auswerten, sehen wir im Post-Fenster, dass er zu einer Funktion evaluiert wurde ( -> a Function ). Jetzt k\u00f6nnen wir unsere Funktion an den Server senden. Daf\u00fcr rufen wir die play -Methode auf die Funktion auf. Was wir hier \u00fcber die play -Methode einer Funktion wissen m\u00fcssen: play generiert auf dem Server einen sogenannten Synth. Synths sind die Klanggeneratoren auf der Server-Seite. Diese Synth wird nach der Erstellung zum Klingen gebracht: ({SinOsc.ar(440, 0, 0.5, 0)}.play) Wenn wir die tats\u00e4chliche Synth, die f\u00fcr uns von play generiert wurde, weiterhin kontrollieren m\u00f6chten (der serverinterne Name wird im Post-Fenster nach dem Auswerten der obigen Zeile angezeigt), k\u00f6nnen wir ganz einfach die ausgegebene Synth einer Variable zuweisen: (x = {SinOsc.ar(440, 0, 0.5, 0)}.play) Jetzt enth\u00e4lt x die Synth, und wir k\u00f6nnen sie zum Beispiel \u00fcber die Variable x ausschalten, indem wir der Variable x die Nachricht free senden: x.free; Das ist praktisch, da wir mit free nur diese eine Synth-Instanz abschalten k\u00f6nnen (im Unterschied zu unserer vorherigen L\u00f6sung Ctrl+. , die den kompletten Server herunterf\u00e4hrt). Wir k\u00f6nnen unserer Funktion Argumente hinzuf\u00fcgen, sodass wir die Parameter unseres SinOsc explizit eingeben k\u00f6nnen: ( x = { arg freq = 440, amp = 0.5; SinOsc.ar(freq, mul: amp) } ) So k\u00f6nnen wir durch die set -Methode unserer Synth-Instanzen die Frequenz oder die Amplitude neu setzen, und das w\u00e4hrend der Synth l\u00e4uft (also w\u00e4hrend unser Sinuston weiter erklingt): // Funktion abspielen x.play; // Amplitude halbieren x.set(\\amp, 0.25); // Die Frequenz um eine Oktave tiefer spielen x.set(\\freq, 220); Das Verst\u00e4ndnis eines Prinzips ist hier von Bedeutung: auch die UGens (wie alles andere auf unserem Rechner!) arbeiten ausschlie\u00dflich mit Zahlen! Das bedeutet, ihre Ausgabe besteht ausschlie\u00dflich aus Zahlen. Das erm\u00f6glicht es uns, eine weitere UGen als Argument f\u00fcr unsere SinOsc UGen einzusetzen. Dadurch wird ein kontinuierlicher Datenstrom an Zahlen an die Haupt-UGen gesendet, die dann als Frequenz (oder auch andere Parameter) interpretiert werden k\u00f6nnen. Ein Beispiel: ( { SinOsc.ar(SinOsc.kr(1, mul: 100, add: 400)) }.play ) Dieses Beispiel demonstriert, wie eine Sinus-Oszillation (SinOsc) mit einer anderen Sinus-Oszillation als Modulator f\u00fcr ihre Frequenz verwendet werden kann.","title":"Starten des Servers"},{"location":"kontakt/","text":"Kontakt Amir.Teymuri@hmtm.de","title":"Kontakt"},{"location":"kontakt/#kontakt","text":"Amir.Teymuri@hmtm.de","title":"Kontakt"},{"location":"lang/","text":"Einf\u00fchrung in die Sprache SuperCollider Namengebung In der Programmierung (f\u00fcr uns Menschen) ist es allgemein einfacher, sich Namen anstelle von komplexen Daten zu merken. Daher k\u00f6nnen wir in unserem Code Namen f\u00fcr unsere Daten zuweisen. Es gibt drei M\u00f6glichkeiten Namen zu definieren: Einzellige Namen Hierf\u00fcr verwenden wir einzelne Kleinbuchstaben, wie folgt: a = 123 Es gibt jedoch eine Ausnahme: \"s\" ist bereits von SuperCollider (SC) reserviert und verweist auf den aktuellen Server. Daher sollte \"s\" nicht \u00fcberschrieben werden. Lokale Namen Alternativ k\u00f6nnen wir vollst\u00e4ndige Namen verwenden. Es ist wichtig, dass diese mit Kleinbuchstaben beginnen. F\u00fcr diese Art von Namen m\u00fcssen sie mit \"var\" deklariert und in einem Code-Block stehen. Au\u00dferhalb der geschweiften Klammern haben diese Namen keine Bedeutung. Code-Bl\u00f6cke sind alle Teile, die sich zwischen zwei geschweiften Klammern befinden: ( var name = 123; name = name + 1; name ) Globale Namen Die letzte Art der Namenszuweisung erfolgt, indem wir vor den Namen eine Tilde setzen. Dadurch m\u00fcssen diese Namen nicht in einem Code-Block eingeschlossen sein und k\u00f6nnen \u00fcberall im Code verwendet werden. Beachten Sie, dass auch hier die Namen mit Kleinbuchstaben beginnen m\u00fcssen: ~drei = 3; ( ~vier = 4; ) ~sieben = ~drei + ~vier; Achtung: Wenn Sie mit Codebl\u00f6cken arbeiten, achten Sie darauf, dass das Ergebnis eines Codeblocks das ist, was in der letzten Zeile des Blocks steht!# Datenstrukturen Und nat\u00fcrlich k\u00f6nnen wir nicht nur Zahlen Namen geben, sondern jeder Art Datenstruktur. In Supercollider gibt es verschiedene Klassen, die ein Blueprint f\u00fcr die Daten repr\u00e4sentieren: Es gibt z.B. Zahlenklassen Integer und Float. Beispiele f\u00fcr diese Klassen sind 1 (Integer) oder 3.14 (Float). Die Klassen werden durch ihre Eigenschaften voneinander unterschieden. Wir k\u00f6nnen die Eigenschaften der Klassen in folgender Schreibweise abfragen: Klasse.Eigenschaft Achtung Wenn es sich bei der Eigenschaft um eine Funktion handelt, ist diese Schreibweise: Klasse.Funktion \u00e4quivalent zu: Funktion(Klasse) Mehr zu Funktionen sp\u00e4ter... Beispiel: Die Klasse Integer (und viele andere Objekte in SC) besitzt u.a. die Eigenschaft class , die angibt zu welcher Klasse eine Integer-Instanz geh\u00f6rt: 1.class Platzieren Sie den Cursor auf der Zeile und dr\u00fccken Sie die Tastenkombination Shift+Enter . Im Post-Window sehen Sie das Ergebnis -> Integer . Wir sagen, der Ausdruck 1.class evaluiert zu Integer . Auch der Quadratwurzel einer Zahl k\u00f6nnen wir durch die Eigenschaft sqrt (f\u00fcr square root) abfragen: 4.sqrt Achten Sie darauf, dass die sqrt -Eigenschaft nur f\u00fcr Zahlen gilt! Wir k\u00f6nnen z.B. diese Eigenschaft bei einem String (eine Zeichenkette eingeschlossen zwischen zwei Anf\u00fchrungszeichen) nicht abfragen, da diese Eigenschaft dort keinen Sinn ergibt. SuperCollider wird uns in dem Fall einen Fehler ausgeben: \"Musik Elektronik\".sqrt Die class -Eigenschaft hingegen kann sinnvollerweise auch auf Strings (und jedes andere Objekt) angewendet werden: \"Musik Elektronik\".class Hier sind einige Klassen (auf der Sprach-Ebene), mit denen wir sehr viel arbeiten werden: Integer ( 1 ) Float ( 3.14 ) String ( \"Musik Elektronik\" ) Array ( [1, 2, 3, 4] ) Boolean ( true ) \u00dcbung Schreiben Sie f\u00fcr jede der folgenden Aufgaben eine Zeile Code: Summe der Zahlen 2.4, 45, 0.234 Produkt der oben genannten Zahlen \u00dcbung Benutzen Sie die size -Eigenschaft, um herauszufinden, aus wie vielen Zeichen der folgende String besteht: \"1k2k3ja98d4nj281jkswe8s0dnmwer8c7q23ij18\" \u00dcbung Die size -Eigenschaft funktioniert auch f\u00fcr Arrays. Finden Sie die Anzahl der Objekte in dem folgenden Array heraus: [1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 3, 4, 5, 6, 5, 4, 3, 2] \u00dcbung Benutzen Sie die sum -Eigenschaft f\u00fcr Arrays, um die Summe aller Zahlen im obigen Array zu berechnen. Funktionen Wie bereits oben beschrieben, k\u00f6nnen wir eine Funktion in der folgenden Schreibweise aufrufen: Objekt.Funktion_des_Objekts oder Funktione_des_objekts(Objekt) Beispiele hierf\u00fcr sind: // Summe eines Arrays berechnen: [1, 2, 3, 4].sum; // \u00c4quivalent zu: sum([1, 2, 3, 4]); // Oder den Kehrwert einer Zahl: 4.reciprocal; // Gleichbedeutend mit: reciprocal(4); Aber manchmal ben\u00f6tigt eine Funktion mehr als eine Eingabe. Ein Beispiel ist das Berechnen einer Potenz, f\u00fcr das wir eine Basis und einen Exponenten ben\u00f6tigen. In SuperCollider l\u00e4sst sich \"zwei hoch drei\" sowohl mit der Punkt-Schreibweise ausdr\u00fccken: 2.pow(3) als auch in Funktions-Schreibweise: pow(2, 3) Ein weiteres Beispiel ist die Funktion linlin , bei der eine Zahl aus einem linearen Zahlenraum auf einen anderen linearen Zahlenraum abgebildet wird. In unserem Beispiel wird die Zahl 0.5 aus dem Bereich von 0 bis 1 auf den Bereich von 10 bis 20 abgebildet, wobei dies der Zahl 15 entspricht. 0.5.linlin(0, 1, 10, 20) Wir k\u00f6nnen auch unsere eigenen Funktionen definieren. Unten habe ich alle Zeilen innerhalb eines Code-Blocks (runden Klammern) platziert, um sie alle zusammen evaluieren zu k\u00f6nnen. Ich verwende auch einen globalen Namen (mit einer Tilde), da ich von \u00fcberall auf meine Funktion zugreifen m\u00f6chte. Die Funktion erh\u00e4lt zwei Zahlen als Argumente und evaluiert zu ihrer Summe der Quadratzahlen. Ich definiere hier meine Funktion und gebe ihr den Namen \"quadsum\". Der Funktionsk\u00f6rper wird zwischen geschweiften Klammern definiert. Der Wert, zu dem die Funktion ausgewertet wird, ist der letzte Ausdruck im Funktionsk\u00f6rper. ( ~quadsum = {} ) Hier definiere ich zuerst, wie viele Eingaben meine Funktion akzeptieren soll, und gebe ihnen eindeutige Namen: ( ~quadsum = { arg num1, num2; } ) Ab hier beginnt die eigentliche Funktionsdefinition. Zuerst speichere ich die Quadrate der beiden Argumente \"num1\" und \"num2\" in internen Variablen. Zur Berechnung der Quadrate der Zahlen verwende ich die eingebaute Funktion \"squared\". ( ~quadsum = { arg num1, num2; var quad1 = num1.squared; var quad2 = num2.squared; } ) Und der letzte Ausdruck ist der eigentliche Wert, den die Funktion zur\u00fcckgibt: ( ~quadsum = { arg num1, num2; var quad1 = num1.squared; var quad2 = num2.squared; quad1 + quad2; } ) Jetzt, mit dem Cursor innerhalb des Blocks (zwischen den beiden runden Klammern), dr\u00fccken Sie die Tastenkombination Ctrl+Enter . Der Block (und der darin enthaltene Code) wird ausgewertet, und wir sehen im Post-Window \"-> a Function\". Jetzt k\u00f6nnen wir unsere Funktion aufrufen: ~quadsum.(2, 3); // -> 13 ~quadsum.(4, 5); // -> 41 Bitte beachten Sie, dass f\u00fcr selbstdefinierte Funktionen die Schreibweise mit dem Punkt nicht existiert. Um unsere eigene Funktion aufzurufen, verwenden wir die folgende Syntax: Funktion.(arg1, arg2, ...) Falls unsere Funktion keine Argumente bekommt, bleibt die Klammer nat\u00fcrlich leer! ( // Zuf\u00e4llige Zahl zwischen 1 und 10 ~rand_1_to_10 = { 1.rrand(10) } ) // Aufruf wie folgt: ~rand_1_to_10.() \u00dcbung Schreiben Sie eine Funktion, die zwei Argumente erh\u00e4lt. Das erste Argument ist ein Array, das eine beliebige Anzahl von Zahlen enth\u00e4lt, und das zweite Argument ist die Index-Nummer eines der Elemente in diesem Array. Das Ergebnis der Funktion sollte ein neues Array sein, in dem jedes Element des Eingabe-Arrays mit der Zahl an der Index-Nummer skaliert ist. Tipp 1: Sie k\u00f6nnen ein Array von Zahlen skalieren, indem Sie das gesamte Array mit einer Zahl multiplizieren. Zum Beispiel: [1, 2, 3, 4] * 10 // -> [10, 20, 30, 40] Tipp 2: Um ein Element an einer bestimmten Index-Nummer aus einem Array zu nehmen, verwenden Sie die at -Methode f\u00fcr Arrays. Diese Methode wird wie folgt aufgerufen (Beachten Sie, dass Index-Nummern 0-basiert sind): [1, 2, 3, 4].at(2) // -> 3 \u00dcbung: Mittlere Zahl finden Schreiben Sie eine Funktion, die drei Zahlen als Argumente erh\u00e4lt und die mittlere Zahl zur\u00fcckgibt. Nennen Sie die Funktion ~findMiddle . Tipp 1: Die sort Methode eines Arrays sortiert das Array in-place . Tipp 2: Die at Methode erlaubt das Abrufen eines Elements an einer bestimmten Indexposition in einem Array. \u00dcbung: Berechne den Durchschnitt Schreiben Sie eine Funktion namens ~average , die eine Liste von Zahlen als Argument erh\u00e4lt und den Durchschnitt dieser Zahlen berechnet und zur\u00fcckgibt. Tipp: Folgende Methoden k\u00f6nnen hilfreich sein: size und sum . \u00dcbung: Umdrehen einer Zeichenkette Schreiben Sie eine Funktion ~reverseString , die eine Zeichenkette als Argument erh\u00e4lt und die umgekehrte Zeichenkette zur\u00fcckgibt. Tipp: Dr\u00fccken Sie die Tastenkombination Shift+Ctrl+D, um die Dokumentationsseite zu durchsuchen. Suchen Sie nach \"reverse\". Dort werden alle Klassen aufgelistet, die diese Funktion/Eigenschaft implementieren. Klicken Sie auf den Eintrag \"ArrayedCollection\". Sie k\u00f6nnen die Methode reverse in Ihrer Funktion verwenden. \u00dcbung: Fl\u00e4cheninhalt eines Rechtecks berechnen Schreiben Sie eine Funktion ~calculateRectangleArea , die die L\u00e4nge und Breite eines Rechtecks als Argumente erh\u00e4lt und den Fl\u00e4cheninhalt des Rechtecks zur\u00fcckgibt. \u00dcbung: Volumen einer Kugel berechnen Schreiben Sie eine Funktion ~calculateSphereVolume , die den Radius einer Kugel als Argument erh\u00e4lt und das Volumen der Kugel berechnet und zur\u00fcckgibt. Tipp 1: Die Formel zur Berechnung des Volumens einer Kugel lautet: V = 4/3 x \u03c0 x r^3 Tipp 2: Die Zahl Pi k\u00f6nnen Sie einfach als pi schreiben. \u00dcbung: Tonleiter generieren Definieren Sie zwei globale Variablen ~majorPattern und ~minorPattern . Definieren Sie eine Funktion ~generateScale , die drei Argumente erh\u00e4lt: eine MIDI-Keynummer, ein Skalenmuster und eine Oktavnummer. Die Funktion soll die gew\u00fcnschte Tonleiter (angegeben als scalePattern , entweder ~majorPattern oder ~minorPattern ) generieren, beginnend bei der MIDI-Keynummer und transponiert um die angegebene Anzahl von Oktaven nach oben oder nach unten. Iterieren mit do und collect In SuperCollider ist das Iterieren \u00fcber Listen und Arrays und das Sammeln von Ergebnissen eine wichtige Technik, um komplexe Operationen auf Daten auszuf\u00fchren. Die Methoden do und collect sind dabei sehr hilfreich. Das do -Muster Die Methode do wird verwendet, um \u00fcber die Elemente einer Liste oder Array zu iterieren und eine Aktion auf jedes Element auszuf\u00fchren. Zum Beispiel: // Iteriert \u00fcber die Array und zeigt jedes Element im Post-Window [1, 2, 3, 4, 5].do { arg element; element.postln; } Dieser Code gibt nacheinander die Zahlen 1 bis 5 aus. Das collect -Muster Die Methode collect wird verwendet, um eine neue Liste/Array zu erstellen, indem eine Aktion auf jedes Element der urspr\u00fcnglichen Liste angewendet wird. Zum Beispiel: // Erstellt eine neue Array/Liste, in der jedes Element um 10 erh\u00f6ht ist var originalList = [1, 2, 3, 4, 5]; var newList = originalList.collect { arg element; element + 10; }; newList.postln; // -> [ 11, 12, 13, 14, 15 ] Beachten Sie, dass collect eine neue Liste erstellt, und Sie k\u00f6nnen sie einer Variablen zuweisen, um das Ergebnis zu speichern. Sie k\u00f6nnen viele andere Operationen mit do und collect durchf\u00fchren, z. B. Filtern von Elementen, Berechnen von Durchschnittswerten, Suchen nach bestimmten Werten usw. \u00dcbung: Quadratzahlen erzeugen Schreiben Sie eine Funktion namens ~squareNumbers , die eine Liste von Zahlen als Argument erh\u00e4lt und eine Liste zur\u00fcckgibt, in der die Quadrate der urspr\u00fcnglichen Zahlen stehen. Benutzen sie collect . \u00dcbung: Fibonacci-Folge generieren Schreiben Sie eine Funktion ~generateFibonacci , die eine positive Ganzzahl n als Argument erh\u00e4lt und die ersten n Zahlen in der Fibonacci-Folge zur\u00fcckgibt.","title":"Sprache"},{"location":"lang/#einfuhrung-in-die-sprache-supercollider","text":"","title":"Einf\u00fchrung in die Sprache SuperCollider"},{"location":"lang/#namengebung","text":"In der Programmierung (f\u00fcr uns Menschen) ist es allgemein einfacher, sich Namen anstelle von komplexen Daten zu merken. Daher k\u00f6nnen wir in unserem Code Namen f\u00fcr unsere Daten zuweisen. Es gibt drei M\u00f6glichkeiten Namen zu definieren:","title":"Namengebung"},{"location":"lang/#einzellige-namen","text":"Hierf\u00fcr verwenden wir einzelne Kleinbuchstaben, wie folgt: a = 123 Es gibt jedoch eine Ausnahme: \"s\" ist bereits von SuperCollider (SC) reserviert und verweist auf den aktuellen Server. Daher sollte \"s\" nicht \u00fcberschrieben werden.","title":"Einzellige Namen"},{"location":"lang/#lokale-namen","text":"Alternativ k\u00f6nnen wir vollst\u00e4ndige Namen verwenden. Es ist wichtig, dass diese mit Kleinbuchstaben beginnen. F\u00fcr diese Art von Namen m\u00fcssen sie mit \"var\" deklariert und in einem Code-Block stehen. Au\u00dferhalb der geschweiften Klammern haben diese Namen keine Bedeutung. Code-Bl\u00f6cke sind alle Teile, die sich zwischen zwei geschweiften Klammern befinden: ( var name = 123; name = name + 1; name )","title":"Lokale Namen"},{"location":"lang/#globale-namen","text":"Die letzte Art der Namenszuweisung erfolgt, indem wir vor den Namen eine Tilde setzen. Dadurch m\u00fcssen diese Namen nicht in einem Code-Block eingeschlossen sein und k\u00f6nnen \u00fcberall im Code verwendet werden. Beachten Sie, dass auch hier die Namen mit Kleinbuchstaben beginnen m\u00fcssen: ~drei = 3; ( ~vier = 4; ) ~sieben = ~drei + ~vier; Achtung: Wenn Sie mit Codebl\u00f6cken arbeiten, achten Sie darauf, dass das Ergebnis eines Codeblocks das ist, was in der letzten Zeile des Blocks steht!# Datenstrukturen Und nat\u00fcrlich k\u00f6nnen wir nicht nur Zahlen Namen geben, sondern jeder Art Datenstruktur. In Supercollider gibt es verschiedene Klassen, die ein Blueprint f\u00fcr die Daten repr\u00e4sentieren: Es gibt z.B. Zahlenklassen Integer und Float. Beispiele f\u00fcr diese Klassen sind 1 (Integer) oder 3.14 (Float). Die Klassen werden durch ihre Eigenschaften voneinander unterschieden. Wir k\u00f6nnen die Eigenschaften der Klassen in folgender Schreibweise abfragen: Klasse.Eigenschaft Achtung Wenn es sich bei der Eigenschaft um eine Funktion handelt, ist diese Schreibweise: Klasse.Funktion \u00e4quivalent zu: Funktion(Klasse) Mehr zu Funktionen sp\u00e4ter... Beispiel: Die Klasse Integer (und viele andere Objekte in SC) besitzt u.a. die Eigenschaft class , die angibt zu welcher Klasse eine Integer-Instanz geh\u00f6rt: 1.class Platzieren Sie den Cursor auf der Zeile und dr\u00fccken Sie die Tastenkombination Shift+Enter . Im Post-Window sehen Sie das Ergebnis -> Integer . Wir sagen, der Ausdruck 1.class evaluiert zu Integer . Auch der Quadratwurzel einer Zahl k\u00f6nnen wir durch die Eigenschaft sqrt (f\u00fcr square root) abfragen: 4.sqrt Achten Sie darauf, dass die sqrt -Eigenschaft nur f\u00fcr Zahlen gilt! Wir k\u00f6nnen z.B. diese Eigenschaft bei einem String (eine Zeichenkette eingeschlossen zwischen zwei Anf\u00fchrungszeichen) nicht abfragen, da diese Eigenschaft dort keinen Sinn ergibt. SuperCollider wird uns in dem Fall einen Fehler ausgeben: \"Musik Elektronik\".sqrt Die class -Eigenschaft hingegen kann sinnvollerweise auch auf Strings (und jedes andere Objekt) angewendet werden: \"Musik Elektronik\".class Hier sind einige Klassen (auf der Sprach-Ebene), mit denen wir sehr viel arbeiten werden: Integer ( 1 ) Float ( 3.14 ) String ( \"Musik Elektronik\" ) Array ( [1, 2, 3, 4] ) Boolean ( true ) \u00dcbung Schreiben Sie f\u00fcr jede der folgenden Aufgaben eine Zeile Code: Summe der Zahlen 2.4, 45, 0.234 Produkt der oben genannten Zahlen \u00dcbung Benutzen Sie die size -Eigenschaft, um herauszufinden, aus wie vielen Zeichen der folgende String besteht: \"1k2k3ja98d4nj281jkswe8s0dnmwer8c7q23ij18\" \u00dcbung Die size -Eigenschaft funktioniert auch f\u00fcr Arrays. Finden Sie die Anzahl der Objekte in dem folgenden Array heraus: [1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 3, 4, 5, 6, 5, 4, 3, 2] \u00dcbung Benutzen Sie die sum -Eigenschaft f\u00fcr Arrays, um die Summe aller Zahlen im obigen Array zu berechnen.","title":"Globale Namen"},{"location":"lang/#funktionen","text":"Wie bereits oben beschrieben, k\u00f6nnen wir eine Funktion in der folgenden Schreibweise aufrufen: Objekt.Funktion_des_Objekts oder Funktione_des_objekts(Objekt) Beispiele hierf\u00fcr sind: // Summe eines Arrays berechnen: [1, 2, 3, 4].sum; // \u00c4quivalent zu: sum([1, 2, 3, 4]); // Oder den Kehrwert einer Zahl: 4.reciprocal; // Gleichbedeutend mit: reciprocal(4); Aber manchmal ben\u00f6tigt eine Funktion mehr als eine Eingabe. Ein Beispiel ist das Berechnen einer Potenz, f\u00fcr das wir eine Basis und einen Exponenten ben\u00f6tigen. In SuperCollider l\u00e4sst sich \"zwei hoch drei\" sowohl mit der Punkt-Schreibweise ausdr\u00fccken: 2.pow(3) als auch in Funktions-Schreibweise: pow(2, 3) Ein weiteres Beispiel ist die Funktion linlin , bei der eine Zahl aus einem linearen Zahlenraum auf einen anderen linearen Zahlenraum abgebildet wird. In unserem Beispiel wird die Zahl 0.5 aus dem Bereich von 0 bis 1 auf den Bereich von 10 bis 20 abgebildet, wobei dies der Zahl 15 entspricht. 0.5.linlin(0, 1, 10, 20) Wir k\u00f6nnen auch unsere eigenen Funktionen definieren. Unten habe ich alle Zeilen innerhalb eines Code-Blocks (runden Klammern) platziert, um sie alle zusammen evaluieren zu k\u00f6nnen. Ich verwende auch einen globalen Namen (mit einer Tilde), da ich von \u00fcberall auf meine Funktion zugreifen m\u00f6chte. Die Funktion erh\u00e4lt zwei Zahlen als Argumente und evaluiert zu ihrer Summe der Quadratzahlen. Ich definiere hier meine Funktion und gebe ihr den Namen \"quadsum\". Der Funktionsk\u00f6rper wird zwischen geschweiften Klammern definiert. Der Wert, zu dem die Funktion ausgewertet wird, ist der letzte Ausdruck im Funktionsk\u00f6rper. ( ~quadsum = {} ) Hier definiere ich zuerst, wie viele Eingaben meine Funktion akzeptieren soll, und gebe ihnen eindeutige Namen: ( ~quadsum = { arg num1, num2; } ) Ab hier beginnt die eigentliche Funktionsdefinition. Zuerst speichere ich die Quadrate der beiden Argumente \"num1\" und \"num2\" in internen Variablen. Zur Berechnung der Quadrate der Zahlen verwende ich die eingebaute Funktion \"squared\". ( ~quadsum = { arg num1, num2; var quad1 = num1.squared; var quad2 = num2.squared; } ) Und der letzte Ausdruck ist der eigentliche Wert, den die Funktion zur\u00fcckgibt: ( ~quadsum = { arg num1, num2; var quad1 = num1.squared; var quad2 = num2.squared; quad1 + quad2; } ) Jetzt, mit dem Cursor innerhalb des Blocks (zwischen den beiden runden Klammern), dr\u00fccken Sie die Tastenkombination Ctrl+Enter . Der Block (und der darin enthaltene Code) wird ausgewertet, und wir sehen im Post-Window \"-> a Function\". Jetzt k\u00f6nnen wir unsere Funktion aufrufen: ~quadsum.(2, 3); // -> 13 ~quadsum.(4, 5); // -> 41 Bitte beachten Sie, dass f\u00fcr selbstdefinierte Funktionen die Schreibweise mit dem Punkt nicht existiert. Um unsere eigene Funktion aufzurufen, verwenden wir die folgende Syntax: Funktion.(arg1, arg2, ...) Falls unsere Funktion keine Argumente bekommt, bleibt die Klammer nat\u00fcrlich leer! ( // Zuf\u00e4llige Zahl zwischen 1 und 10 ~rand_1_to_10 = { 1.rrand(10) } ) // Aufruf wie folgt: ~rand_1_to_10.() \u00dcbung Schreiben Sie eine Funktion, die zwei Argumente erh\u00e4lt. Das erste Argument ist ein Array, das eine beliebige Anzahl von Zahlen enth\u00e4lt, und das zweite Argument ist die Index-Nummer eines der Elemente in diesem Array. Das Ergebnis der Funktion sollte ein neues Array sein, in dem jedes Element des Eingabe-Arrays mit der Zahl an der Index-Nummer skaliert ist. Tipp 1: Sie k\u00f6nnen ein Array von Zahlen skalieren, indem Sie das gesamte Array mit einer Zahl multiplizieren. Zum Beispiel: [1, 2, 3, 4] * 10 // -> [10, 20, 30, 40] Tipp 2: Um ein Element an einer bestimmten Index-Nummer aus einem Array zu nehmen, verwenden Sie die at -Methode f\u00fcr Arrays. Diese Methode wird wie folgt aufgerufen (Beachten Sie, dass Index-Nummern 0-basiert sind): [1, 2, 3, 4].at(2) // -> 3 \u00dcbung: Mittlere Zahl finden Schreiben Sie eine Funktion, die drei Zahlen als Argumente erh\u00e4lt und die mittlere Zahl zur\u00fcckgibt. Nennen Sie die Funktion ~findMiddle . Tipp 1: Die sort Methode eines Arrays sortiert das Array in-place . Tipp 2: Die at Methode erlaubt das Abrufen eines Elements an einer bestimmten Indexposition in einem Array. \u00dcbung: Berechne den Durchschnitt Schreiben Sie eine Funktion namens ~average , die eine Liste von Zahlen als Argument erh\u00e4lt und den Durchschnitt dieser Zahlen berechnet und zur\u00fcckgibt. Tipp: Folgende Methoden k\u00f6nnen hilfreich sein: size und sum . \u00dcbung: Umdrehen einer Zeichenkette Schreiben Sie eine Funktion ~reverseString , die eine Zeichenkette als Argument erh\u00e4lt und die umgekehrte Zeichenkette zur\u00fcckgibt. Tipp: Dr\u00fccken Sie die Tastenkombination Shift+Ctrl+D, um die Dokumentationsseite zu durchsuchen. Suchen Sie nach \"reverse\". Dort werden alle Klassen aufgelistet, die diese Funktion/Eigenschaft implementieren. Klicken Sie auf den Eintrag \"ArrayedCollection\". Sie k\u00f6nnen die Methode reverse in Ihrer Funktion verwenden. \u00dcbung: Fl\u00e4cheninhalt eines Rechtecks berechnen Schreiben Sie eine Funktion ~calculateRectangleArea , die die L\u00e4nge und Breite eines Rechtecks als Argumente erh\u00e4lt und den Fl\u00e4cheninhalt des Rechtecks zur\u00fcckgibt. \u00dcbung: Volumen einer Kugel berechnen Schreiben Sie eine Funktion ~calculateSphereVolume , die den Radius einer Kugel als Argument erh\u00e4lt und das Volumen der Kugel berechnet und zur\u00fcckgibt. Tipp 1: Die Formel zur Berechnung des Volumens einer Kugel lautet: V = 4/3 x \u03c0 x r^3 Tipp 2: Die Zahl Pi k\u00f6nnen Sie einfach als pi schreiben. \u00dcbung: Tonleiter generieren Definieren Sie zwei globale Variablen ~majorPattern und ~minorPattern . Definieren Sie eine Funktion ~generateScale , die drei Argumente erh\u00e4lt: eine MIDI-Keynummer, ein Skalenmuster und eine Oktavnummer. Die Funktion soll die gew\u00fcnschte Tonleiter (angegeben als scalePattern , entweder ~majorPattern oder ~minorPattern ) generieren, beginnend bei der MIDI-Keynummer und transponiert um die angegebene Anzahl von Oktaven nach oben oder nach unten.","title":"Funktionen"},{"location":"lang/#iterieren-mit-do-und-collect","text":"In SuperCollider ist das Iterieren \u00fcber Listen und Arrays und das Sammeln von Ergebnissen eine wichtige Technik, um komplexe Operationen auf Daten auszuf\u00fchren. Die Methoden do und collect sind dabei sehr hilfreich.","title":"Iterieren mit do und collect"},{"location":"lang/#das-do-muster","text":"Die Methode do wird verwendet, um \u00fcber die Elemente einer Liste oder Array zu iterieren und eine Aktion auf jedes Element auszuf\u00fchren. Zum Beispiel: // Iteriert \u00fcber die Array und zeigt jedes Element im Post-Window [1, 2, 3, 4, 5].do { arg element; element.postln; } Dieser Code gibt nacheinander die Zahlen 1 bis 5 aus.","title":"Das do-Muster"},{"location":"lang/#das-collect-muster","text":"Die Methode collect wird verwendet, um eine neue Liste/Array zu erstellen, indem eine Aktion auf jedes Element der urspr\u00fcnglichen Liste angewendet wird. Zum Beispiel: // Erstellt eine neue Array/Liste, in der jedes Element um 10 erh\u00f6ht ist var originalList = [1, 2, 3, 4, 5]; var newList = originalList.collect { arg element; element + 10; }; newList.postln; // -> [ 11, 12, 13, 14, 15 ] Beachten Sie, dass collect eine neue Liste erstellt, und Sie k\u00f6nnen sie einer Variablen zuweisen, um das Ergebnis zu speichern. Sie k\u00f6nnen viele andere Operationen mit do und collect durchf\u00fchren, z. B. Filtern von Elementen, Berechnen von Durchschnittswerten, Suchen nach bestimmten Werten usw. \u00dcbung: Quadratzahlen erzeugen Schreiben Sie eine Funktion namens ~squareNumbers , die eine Liste von Zahlen als Argument erh\u00e4lt und eine Liste zur\u00fcckgibt, in der die Quadrate der urspr\u00fcnglichen Zahlen stehen. Benutzen sie collect . \u00dcbung: Fibonacci-Folge generieren Schreiben Sie eine Funktion ~generateFibonacci , die eine positive Ganzzahl n als Argument erh\u00e4lt und die ersten n Zahlen in der Fibonacci-Folge zur\u00fcckgibt.","title":"Das collect-Muster"}]}